{"config":{"lang":["de","en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"redis_robot_comm","text":"<p>Redis-basiertes Kommunikations- und Streaming-Package f\u00fcr Roboteranwendungen.</p> <p>Das <code>redis_robot_comm</code> Package bietet eine effiziente Redis-basierte Kommunikationsinfrastruktur f\u00fcr Roboteranwendungen. Es erm\u00f6glicht den Austausch von Kamerabildern, Objektdetektionen, Metadaten und Text-Overlays zwischen verschiedenen Prozessen oder Systemen in Echtzeit.</p>"},{"location":"#hauptfunktionen","title":"Hauptfunktionen","text":"<ul> <li>\ud83d\udce6 Objekterkennung - Streaming von Detektionsergebnissen \u00fcber <code>RedisMessageBroker</code></li> <li>\ud83d\udcf7 Bild-Streaming - Variable Bildgr\u00f6\u00dfen mit JPEG-Kompression \u00fcber <code>RedisImageStreamer</code></li> <li>\ud83c\udff7\ufe0f Label-Verwaltung - Dynamische Objektlabels mit <code>RedisLabelManager</code></li> <li>\ud83d\udcdd Text-Overlays - Video-Aufnahme-Integration mit <code>RedisTextOverlayManager</code></li> <li>\u26a1 Echtzeitf\u00e4hig - Sub-Millisekunden-Latenz f\u00fcr lokale Redis-Server</li> <li>\ud83d\udd04 Asynchron - Entkoppelte Producer-Consumer-Architektur</li> <li>\ud83d\udcca Metadaten - Automatische Zeitstempel, Roboterposen, Workspace-Informationen</li> <li>\ud83c\udfaf Robotik-optimiert - Speziell f\u00fcr Pick-and-Place und Vision-Anwendungen</li> </ul>"},{"location":"#anwendungsfalle","title":"Anwendungsf\u00e4lle","text":"<p>Das Package wird in Robotik-Frameworks als Kommunikations-Backbone eingesetzt:</p> <ul> <li>vision_detect_segment - Objekterkennung mit OwlV2, YOLO-World, YOLOE, Grounding-DINO</li> <li>robot_environment - Robotersteuerung mit visueller Objekterkennung</li> <li>robot_mcp - LLM-basierte Robotersteuerung mit MCP</li> </ul>"},{"location":"#datenfluss","title":"Datenfluss","text":""},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog_1","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#unreleased","title":"[unreleased]","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Ensure root index.html is created on gh-pages for redirect</li> <li>Format increment script and restore action versions</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Implement complete bilingual documentation ecosystem with MkDocs</li> <li>Implement complete bilingual documentation ecosystem with MkDocs</li> <li>Implement complete bilingual documentation ecosystem with MkDocs</li> <li>Fix documentation deployment and improve CI workflow</li> <li>Implement automated versioning system</li> </ul>"},{"location":"configuration/","title":"Konfiguration","text":"<p><code>redis_robot_comm</code> kann \u00fcber Umgebungsvariablen oder direkt im Code konfiguriert werden.</p>"},{"location":"configuration/#umgebungsvariablen","title":"Umgebungsvariablen","text":"<p>Die folgenden Umgebungsvariablen werden unterst\u00fctzt:</p> Variable Beschreibung Standardwert <code>REDIS_HOST</code> Hostname des Redis-Servers <code>localhost</code> <code>REDIS_PORT</code> Port des Redis-Servers <code>6379</code> <code>REDIS_DB</code> Index der Redis-Datenbank <code>0</code> <code>REDIS_PASSWORD</code> Passwort f\u00fcr Redis (optional) <code>None</code>"},{"location":"configuration/#konfiguration-im-code","title":"Konfiguration im Code","text":"<p>Sie k\u00f6nnen die Konfiguration beim Initialisieren der Manager-Klassen \u00fcbergeben:</p> <pre><code>from redis_robot_comm import RedisMessageBroker\n\n# Explizite Parameter\nbroker = RedisMessageBroker(\n    host=\"192.168.1.100\",\n    port=6380,\n    db=1,\n    stream_name=\"my_objects\"\n)\n</code></pre> <p>Alternativ k\u00f6nnen Sie ein <code>RedisConfig</code>-Objekt verwenden:</p> <pre><code>from redis_robot_comm.config import RedisConfig\nfrom redis_robot_comm import RedisImageStreamer\n\nconfig = RedisConfig(\n    host=\"localhost\",\n    port=6379,\n    password=\"secret_password\"\n)\n\nstreamer = RedisImageStreamer(config=config)\n</code></pre>"},{"location":"configuration/#logging-konfiguration","title":"Logging-Konfiguration","text":"<p>Alle Klassen verf\u00fcgen \u00fcber ein <code>verbose</code>-Attribut, um detaillierte Protokollausgaben zu aktivieren:</p> <pre><code>broker = RedisMessageBroker()\nbroker.verbose = True\n</code></pre>"},{"location":"getting-started/","title":"Erste Schritte","text":"<p>Diese Anleitung hilft Ihnen beim schnellen Einstieg in <code>redis_robot_comm</code>.</p>"},{"location":"getting-started/#voraussetzungen","title":"Voraussetzungen","text":"<ul> <li>Python \u2265 3.8</li> <li>Redis-Server \u2265 5.0 (f\u00fcr Streams-Unterst\u00fctzung)</li> </ul>"},{"location":"getting-started/#schnellstart-beispiele","title":"Schnellstart-Beispiele","text":""},{"location":"getting-started/#1-objekterkennung","title":"1. Objekterkennung","text":"<pre><code>from redis_robot_comm import RedisMessageBroker\nimport time\n\nbroker = RedisMessageBroker()\n\n# Verbindung testen\nif broker.test_connection():\n    print(\"\u2713 Verbunden mit Redis\")\n\n# Beispielobjekte publizieren\nobjects = [\n    {\n        \"id\": \"obj_1\",\n        \"class_name\": \"cube\",\n        \"confidence\": 0.95,\n        \"position\": {\"x\": 0.1, \"y\": 0.2, \"z\": 0.05},\n        \"timestamp\": time.time()\n    }\n]\n\nbroker.publish_objects(objects)\n\n# Neueste Objekte abrufen\nlatest = broker.get_latest_objects(max_age_seconds=2.0)\nprint(f\"Gefundene Objekte: {len(latest)}\")\n</code></pre>"},{"location":"getting-started/#2-bild-streaming","title":"2. Bild-Streaming","text":"<pre><code>from redis_robot_comm import RedisImageStreamer\nimport cv2\n\nstreamer = RedisImageStreamer()\n\n# Beispielbild laden\nimage = cv2.imread(\"example.jpg\")\n\n# Bild ver\u00f6ffentlichen\nstreamer.publish_image(image, compress_jpeg=True, quality=85)\n\n# Neuestes Bild abrufen\nresult = streamer.get_latest_image()\nif result:\n    img, metadata = result\n    cv2.imshow(\"Empfangenes Bild\", img)\n    cv2.waitKey(0)\n</code></pre>"},{"location":"getting-started/#weitere-informationen","title":"Weitere Informationen","text":"<p>F\u00fcr detaillierte Informationen zu den einzelnen Modulen besuchen Sie bitte die Abschnitte Benutzung und API-Referenz.</p>"},{"location":"installation/","title":"Installation","text":"<p>In diesem Abschnitt wird beschrieben, wie Sie <code>redis_robot_comm</code> installieren und einrichten.</p>"},{"location":"installation/#paket-installieren","title":"Paket installieren","text":"<p>Sie k\u00f6nnen das Paket direkt aus dem Quellcode installieren:</p> <pre><code>git clone https://github.com/dgaida/redis_robot_comm.git\ncd redis_robot_comm\npip install -e .\n</code></pre>"},{"location":"installation/#redis-server-einrichten","title":"Redis-Server einrichten","text":"<p><code>redis_robot_comm</code> ben\u00f6tigt einen laufenden Redis-Server (Version \u2265 5.0).</p>"},{"location":"installation/#mit-docker-empfohlen","title":"Mit Docker (empfohlen)","text":"<p>Dies ist die einfachste Methode, um Redis schnell zu starten:</p> <pre><code>docker run -d -p 6379:6379 --name redis-robot redis:alpine\n</code></pre>"},{"location":"installation/#lokale-installation","title":"Lokale Installation","text":"<p>Ubuntu/Debian: <pre><code>sudo apt-get update\nsudo apt-get install redis-server\nsudo systemctl start redis-server\n</code></pre></p> <p>macOS: <pre><code>brew install redis\nbrew services start redis\n</code></pre></p>"},{"location":"installation/#installation-verifizieren","title":"Installation verifizieren","text":"<p>Nach der Installation k\u00f6nnen Sie die Verbindung mit einem einfachen Skript testen:</p> <pre><code>from redis_robot_comm import RedisMessageBroker\n\ntry:\n    broker = RedisMessageBroker()\n    if broker.test_connection():\n        print(\"\u2713 Installation erfolgreich: Verbindung zu Redis hergestellt.\")\n    else:\n        print(\"\u2717 Verbindung zu Redis fehlgeschlagen.\")\nexcept Exception as e:\n    print(f\"\u2717 Fehler bei der Verifizierung: {e}\")\n</code></pre>"},{"location":"troubleshooting/","title":"Fehlerbehebung","text":"<p>Hier finden Sie L\u00f6sungen f\u00fcr h\u00e4ufig auftretende Probleme.</p>"},{"location":"troubleshooting/#verbindungsprobleme-zu-redis","title":"Verbindungsprobleme zu Redis","text":""},{"location":"troubleshooting/#fehlermeldung-failed-to-connect-to-redis","title":"Fehlermeldung: <code>Failed to connect to Redis</code>","text":"<p>M\u00f6gliche Ursachen: 1. Redis-Server l\u00e4uft nicht. 2. Falsche Host- oder Port-Konfiguration. 3. Firewall blockiert den Zugriff.</p> <p>L\u00f6sungen: * \u00dcberpr\u00fcfen Sie, ob Redis l\u00e4uft: <code>redis-cli ping</code> sollte mit <code>PONG</code> antworten. * Stellen Sie sicher, dass der Docker-Container l\u00e4uft (falls verwendet): <code>docker ps</code>. * \u00dcberpr\u00fcfen Sie Ihre <code>REDIS_HOST</code> und <code>REDIS_PORT</code> Einstellungen.</p>"},{"location":"troubleshooting/#performance-probleme","title":"Performance-Probleme","text":""},{"location":"troubleshooting/#hohe-latenz-beim-bild-streaming","title":"Hohe Latenz beim Bild-Streaming","text":"<p>M\u00f6gliche Ursachen: 1. Gro\u00dfe Bilder ohne Kompression. 2. Netzwerk-Bandbreite ist ausgelastet. 3. Hohe CPU-Last durch JPEG-Kodierung.</p> <p>L\u00f6sungen: * Aktivieren Sie die JPEG-Kompression: <code>compress_jpeg=True</code>. * Reduzieren Sie die JPEG-Qualit\u00e4t: <code>quality=70</code>. * Verringern Sie die Bildaufl\u00f6sung vor dem Senden.</p>"},{"location":"troubleshooting/#datenverlust","title":"Datenverlust","text":""},{"location":"troubleshooting/#alte-nachrichten-verschwinden-aus-dem-stream","title":"Alte Nachrichten verschwinden aus dem Stream","text":"<p>Ursache: * Die Parameter <code>maxlen</code> (standardm\u00e4\u00dfig 500 f\u00fcr Objekte, 5 f\u00fcr Bilder) begrenzen die Anzahl der gespeicherten Eintr\u00e4ge.</p> <p>L\u00f6sung: * Erh\u00f6hen Sie den <code>maxlen</code> Wert beim Ver\u00f6ffentlichen, falls Sie einen gr\u00f6\u00dferen Puffer ben\u00f6tigen.</p>"},{"location":"troubleshooting/#debugging","title":"Debugging","text":"<p>Aktivieren Sie den <code>verbose</code>-Modus, um mehr Informationen \u00fcber interne Vorg\u00e4nge zu erhalten:</p> <pre><code>streamer = RedisImageStreamer()\nstreamer.verbose = True\n</code></pre>"},{"location":"api/broker/","title":"RedisMessageBroker","text":""},{"location":"api/broker/#redis_robot_comm.redis_client.RedisMessageBroker","title":"<code>redis_robot_comm.redis_client.RedisMessageBroker</code>","text":"<p>Redis-basierter Message Broker f\u00fcr die Ver\u00f6ffentlichung und den Empfang von Objekterkennungsergebnissen.</p> <p>Redis-based message broker for publishing and consuming object detection results.</p> <p>Diese Klasse bietet eine High-Level-Schnittstelle f\u00fcr das Streaming von Objekterkennungsdaten \u00fcber Redis Streams und unterst\u00fctzt mehrere Producer und Consumer mit automatischer Stream-Verwaltung.</p> <p>This class provides a high-level interface for streaming object detection data through Redis Streams, supporting multiple producers and consumers with automatic stream management.</p> <p>Attributes:</p> Name Type Description <code>verbose</code> <code>bool</code> <p>Aktiviert detaillierte Protokollausgaben. (Enable verbose logging output).</p> <code>client</code> <code>Redis</code> <p>Instanz des zugrunde liegenden Redis-Clients. (Underlying Redis client instance).</p> <code>stream_name</code> <code>str</code> <p>Name des Redis-Streams f\u00fcr Objekterkennungen. (Name of the Redis stream for object detections).</p> Source code in <code>redis_robot_comm/redis_client.py</code> <pre><code>class RedisMessageBroker:\n    \"\"\"\n    Redis-basierter Message Broker f\u00fcr die Ver\u00f6ffentlichung und den Empfang von Objekterkennungsergebnissen.\n\n    Redis-based message broker for publishing and consuming object detection results.\n\n    Diese Klasse bietet eine High-Level-Schnittstelle f\u00fcr das Streaming von Objekterkennungsdaten\n    \u00fcber Redis Streams und unterst\u00fctzt mehrere Producer und Consumer mit automatischer\n    Stream-Verwaltung.\n\n    This class provides a high-level interface for streaming object detection data\n    through Redis Streams, supporting multiple producers and consumers with automatic\n    stream management.\n\n    Attributes:\n        verbose (bool): Aktiviert detaillierte Protokollausgaben. (Enable verbose logging output).\n        client (redis.Redis): Instanz des zugrunde liegenden Redis-Clients. (Underlying Redis client instance).\n        stream_name (str): Name des Redis-Streams f\u00fcr Objekterkennungen. (Name of the Redis stream for object detections).\n    \"\"\"\n\n    def __init__(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        db: Optional[int] = None,\n        stream_name: str = \"detected_objects\",\n        config: Optional[RedisConfig] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialisiert den Redis Message Broker.\n\n        Initialize the Redis message broker.\n\n        Args:\n            host (Optional[str]): Hostname oder IP-Adresse des Redis-Servers. (Redis server hostname or IP address).\n            port (Optional[int]): Port des Redis-Servers. (Redis server port).\n            db (Optional[int]): Index der Redis-Datenbank. (Redis database index).\n            stream_name (str): Name des zu verwendenden Redis-Streams. (Name of the Redis stream to use).\n            config (Optional[RedisConfig]): Optionale RedisConfig-Instanz. (Optional RedisConfig instance).\n\n        Raises:\n            RedisConnectionError: Wenn die Verbindung zu Redis fehlschl\u00e4gt. (If connection to Redis fails).\n        \"\"\"\n        if config is None:\n            config = get_redis_config()\n\n        # Override config with explicit parameters if provided\n        host = host or config.host\n        port = port or config.port\n        db = db if db is not None else config.db\n\n        self.verbose: bool = False\n        validate_stream_name(stream_name)\n        self.stream_name: str = stream_name\n        try:\n            self.client = redis.Redis(\n                host=host,\n                port=port,\n                db=db,\n                password=config.password,\n                socket_timeout=config.socket_timeout,\n                socket_connect_timeout=config.socket_connect_timeout,\n                retry_on_timeout=config.retry_on_timeout,\n                max_connections=config.max_connections,\n                decode_responses=True,\n            )\n            self.client.ping()\n        except RedisError as e:\n            raise RedisConnectionError(f\"Failed to connect to Redis: {e}\") from e\n\n    @retry_on_connection_error(max_attempts=3, delay=0.5)\n    def publish_objects(\n        self,\n        objects: List[ObjectDict],\n        camera_pose: Optional[CameraPose] = None,\n        maxlen: int = 500,\n    ) -&gt; Optional[StreamID]:\n        \"\"\"\n        Ver\u00f6ffentlicht erkannte Objekte im Redis-Stream.\n\n        Publish detected objects to the Redis stream.\n\n        Args:\n            objects (List[ObjectDict]): Liste von Dictionaries der erkannten Objekte. (List of detected object dictionaries).\n            camera_pose (Optional[CameraPose]): Optionale Informationen zur Kamerapose. (Optional camera pose information).\n            maxlen (int): Maximale Stream-L\u00e4nge (\u00e4ltere Eintr\u00e4ge werden gek\u00fcrzt). (Maximum stream length (older entries are trimmed)).\n\n        Returns:\n            Optional[StreamID]: ID des Redis-Stream-Eintrags oder None, wenn die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).\n\n        Raises:\n            RedisPublishError: Wenn die Ver\u00f6ffentlichung bei Redis fehlschl\u00e4gt. (If publishing to Redis fails).\n        \"\"\"\n        validate_objects(objects)\n\n        message = {\n            \"timestamp\": str(time.time()),\n            \"objects\": json.dumps(objects),\n            \"camera_pose\": json.dumps(camera_pose or {}),\n        }\n\n        try:\n            result = self.client.xadd(\n                self.stream_name,\n                message,\n                maxlen=maxlen,\n                approximate=True,\n            )\n\n            if self.verbose:\n                logger.info(f\"Published {len(objects)} objects to {self.stream_name}: {result}\")\n            return cast(Optional[StreamID], result)\n        except RedisError as e:\n            logger.error(f\"Error publishing objects: {e}\")\n            raise RedisPublishError(f\"Failed to publish objects: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Unexpected error publishing objects: {e}\")\n            return None\n\n    def get_latest_objects(self, max_age_seconds: float = 2.0) -&gt; List[ObjectDict]:\n        \"\"\"\n        Ruft die neuesten Objekterkennungen aus dem Stream ab.\n\n        Retrieve the most recent object detections from the stream.\n\n        Args:\n            max_age_seconds (float): Maximales Alter der abzurufenden Objekte. (Maximum age of objects to retrieve).\n\n        Returns:\n            List[ObjectDict]: Liste der erkannten Objekte oder leere Liste, falls keine gefunden wurden oder diese zu alt sind. (List of detected objects, or empty list if none found or too old).\n\n        Raises:\n            RedisRetrievalError: Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).\n        \"\"\"\n        try:\n            # Get the latest message from the stream\n            messages = self.client.xrevrange(self.stream_name, count=1)\n            if not messages:\n                if self.verbose:\n                    logger.debug(f\"No messages found in {self.stream_name}\")\n                return []\n\n            # Parse the latest message\n            msg_id, fields = messages[0]\n\n            # Check if message is fresh enough\n            msg_timestamp = float(fields.get(\"timestamp\", \"0\"))\n            current_time = time.time()\n\n            if current_time - msg_timestamp &gt; max_age_seconds:\n                if self.verbose:\n                    logger.debug(f\"Latest objects too old: {current_time - msg_timestamp:.2f}s &gt; {max_age_seconds}s\")\n                return []\n\n            # Parse and return objects\n            objects_json = fields.get(\"objects\", \"[]\")\n            objects = json.loads(objects_json)\n            if self.verbose:\n                logger.info(f\"Retrieved {len(objects)} fresh objects\")\n            return cast(List[ObjectDict], objects)\n\n        except RedisError as e:\n            logger.error(f\"Error getting latest objects: {e}\")\n            raise RedisRetrievalError(f\"Failed to retrieve objects: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Unexpected error getting latest objects: {e}\")\n            return []\n\n    def get_objects_in_timerange(self, start_timestamp: float, end_timestamp: Optional[float] = None) -&gt; List[ObjectDict]:\n        \"\"\"\n        Ruft Objekte ab, die innerhalb eines bestimmten Zeitbereichs ver\u00f6ffentlicht wurden.\n\n        Retrieve objects published within a specific time range.\n\n        Args:\n            start_timestamp (float): Startzeit als Unix-Zeitstempel. (Start time as Unix timestamp).\n            end_timestamp (Optional[float]): Endzeit als Unix-Zeitstempel. Falls None, wird die aktuelle Zeit verwendet. (End time as Unix timestamp. If None, uses current time).\n\n        Returns:\n            List[ObjectDict]: Liste der im Intervall gefundenen Objekte. (List of objects found in the interval).\n\n        Raises:\n            RedisRetrievalError: Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).\n        \"\"\"\n        if end_timestamp is None:\n            end_timestamp = time.time()\n\n        try:\n            # Convert timestamps to Redis stream IDs\n            start_id = f\"{int(start_timestamp * 1000)}-0\"\n            end_id = f\"{int(end_timestamp * 1000)}-0\"\n\n            messages = self.client.xrange(self.stream_name, start_id, end_id)\n\n            all_objects = []\n            for msg_id, fields in messages:\n                objects_json = fields.get(\"objects\", \"[]\")\n                objects = json.loads(objects_json)\n                all_objects.extend(objects)\n\n            if self.verbose:\n                logger.info(f\"Retrieved {len(all_objects)} objects from timerange\")\n            return cast(List[ObjectDict], all_objects)\n\n        except RedisError as e:\n            logger.error(f\"Error getting objects in timerange: {e}\")\n            raise RedisRetrievalError(f\"Failed to retrieve objects in timerange: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Unexpected error getting objects in timerange: {e}\")\n            return []\n\n    def subscribe_objects(self, callback: Callable[[Dict[str, Any]], None]) -&gt; None:\n        \"\"\"\n        Startet ein blockierendes Abonnement f\u00fcr Objekterkennungen.\n\n        Start a blocking subscription for object detections.\n\n        Args:\n            callback (Callable[[Dict[str, Any]], None]): Funktion, die ein Dictionary mit 'objects', 'camera_pose' und 'timestamp' erh\u00e4lt. (Function receiving a dictionary with 'objects', 'camera_pose', and 'timestamp').\n        \"\"\"\n        if self.verbose:\n            logger.info(f\"Starting to listen for object detections on {self.stream_name}...\")\n        last_id = \"$\"  # Start from newest\n\n        try:\n            while True:\n                # Block for up to 1 second waiting for new messages\n                messages = self.client.xread({self.stream_name: last_id}, block=1000)\n\n                for stream, msgs in messages:\n                    for msg_id, fields in msgs:\n                        try:\n                            # Parse objects from JSON\n                            objects_json = fields.get(\"objects\", \"[]\")\n                            objects = json.loads(objects_json)\n\n                            # Parse camera pose if available\n                            camera_pose_json = fields.get(\"camera_pose\", \"{}\")\n                            camera_pose = json.loads(camera_pose_json)\n\n                            # Call callback with parsed data\n                            callback(\n                                {\n                                    \"objects\": objects,\n                                    \"camera_pose\": camera_pose,\n                                    \"timestamp\": float(fields.get(\"timestamp\", \"0\")),\n                                }\n                            )\n\n                            last_id = msg_id\n\n                        except Exception as e:\n                            logger.error(f\"Error processing message {msg_id}: {e}\")\n\n        except KeyboardInterrupt:\n            logger.info(\"Stopped listening for object detections\")\n        except RedisError as e:\n            logger.error(f\"Redis error in subscribe_objects: {e}\")\n            raise RedisRetrievalError(f\"Subscription failed: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Unexpected error in subscribe_objects: {e}\")\n\n    def clear_stream(self) -&gt; bool:\n        \"\"\"\n        L\u00f6scht den Objekterkennungs-Stream.\n\n        Clear the object detection stream.\n\n        Returns:\n            bool: True bei Erfolg, False andernfalls. (True if successful, False otherwise).\n        \"\"\"\n        try:\n            result = self.client.delete(self.stream_name)\n            if self.verbose:\n                logger.info(f\"Cleared {self.stream_name} stream: {result}\")\n            return bool(result)\n        except Exception as e:\n            logger.error(f\"Error clearing stream: {e}\")\n            return False\n\n    def get_stream_info(self) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Ruft Informationen \u00fcber den Redis-Stream ab.\n\n        Retrieve information about the Redis stream.\n\n        Returns:\n            Optional[Dict[str, Any]]: Dictionary mit Stream-Informationen oder None, falls ein Fehler auftritt. (Dictionary with stream info, or None if an error occurs).\n        \"\"\"\n        try:\n            info = self.client.xinfo_stream(self.stream_name)\n            if self.verbose:\n                logger.info(f\"Stream info: {info}\")\n            return cast(Optional[Dict[str, Any]], info)\n        except Exception as e:\n            logger.error(f\"Error getting stream info: {e}\")\n            return None\n\n    def test_connection(self) -&gt; bool:\n        \"\"\"\n        Testet die Verbindung zum Redis-Server.\n\n        Test the connection to the Redis server.\n\n        Returns:\n            bool: True, wenn die Verbindung erfolgreich ist, andernfalls False. (True if connection is successful, False otherwise).\n        \"\"\"\n        try:\n            pong = self.client.ping()\n            if self.verbose:\n                logger.info(f\"Redis connection test: {'OK' if pong else 'FAILED'}\")\n            return bool(pong)\n        except Exception as e:\n            logger.error(f\"Redis connection failed: {e}\")\n            return False\n</code></pre>"},{"location":"api/broker/#redis_robot_comm.redis_client.RedisMessageBroker-functions","title":"Functions","text":""},{"location":"api/broker/#redis_robot_comm.redis_client.RedisMessageBroker.__init__","title":"<code>__init__(host=None, port=None, db=None, stream_name='detected_objects', config=None)</code>","text":"<p>Initialisiert den Redis Message Broker.</p> <p>Initialize the Redis message broker.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>Optional[str]</code> <p>Hostname oder IP-Adresse des Redis-Servers. (Redis server hostname or IP address).</p> <code>None</code> <code>port</code> <code>Optional[int]</code> <p>Port des Redis-Servers. (Redis server port).</p> <code>None</code> <code>db</code> <code>Optional[int]</code> <p>Index der Redis-Datenbank. (Redis database index).</p> <code>None</code> <code>stream_name</code> <code>str</code> <p>Name des zu verwendenden Redis-Streams. (Name of the Redis stream to use).</p> <code>'detected_objects'</code> <code>config</code> <code>Optional[RedisConfig]</code> <p>Optionale RedisConfig-Instanz. (Optional RedisConfig instance).</p> <code>None</code> <p>Raises:</p> Type Description <code>RedisConnectionError</code> <p>Wenn die Verbindung zu Redis fehlschl\u00e4gt. (If connection to Redis fails).</p> Source code in <code>redis_robot_comm/redis_client.py</code> <pre><code>def __init__(\n    self,\n    host: Optional[str] = None,\n    port: Optional[int] = None,\n    db: Optional[int] = None,\n    stream_name: str = \"detected_objects\",\n    config: Optional[RedisConfig] = None,\n) -&gt; None:\n    \"\"\"\n    Initialisiert den Redis Message Broker.\n\n    Initialize the Redis message broker.\n\n    Args:\n        host (Optional[str]): Hostname oder IP-Adresse des Redis-Servers. (Redis server hostname or IP address).\n        port (Optional[int]): Port des Redis-Servers. (Redis server port).\n        db (Optional[int]): Index der Redis-Datenbank. (Redis database index).\n        stream_name (str): Name des zu verwendenden Redis-Streams. (Name of the Redis stream to use).\n        config (Optional[RedisConfig]): Optionale RedisConfig-Instanz. (Optional RedisConfig instance).\n\n    Raises:\n        RedisConnectionError: Wenn die Verbindung zu Redis fehlschl\u00e4gt. (If connection to Redis fails).\n    \"\"\"\n    if config is None:\n        config = get_redis_config()\n\n    # Override config with explicit parameters if provided\n    host = host or config.host\n    port = port or config.port\n    db = db if db is not None else config.db\n\n    self.verbose: bool = False\n    validate_stream_name(stream_name)\n    self.stream_name: str = stream_name\n    try:\n        self.client = redis.Redis(\n            host=host,\n            port=port,\n            db=db,\n            password=config.password,\n            socket_timeout=config.socket_timeout,\n            socket_connect_timeout=config.socket_connect_timeout,\n            retry_on_timeout=config.retry_on_timeout,\n            max_connections=config.max_connections,\n            decode_responses=True,\n        )\n        self.client.ping()\n    except RedisError as e:\n        raise RedisConnectionError(f\"Failed to connect to Redis: {e}\") from e\n</code></pre>"},{"location":"api/broker/#redis_robot_comm.redis_client.RedisMessageBroker.clear_stream","title":"<code>clear_stream()</code>","text":"<p>L\u00f6scht den Objekterkennungs-Stream.</p> <p>Clear the object detection stream.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True bei Erfolg, False andernfalls. (True if successful, False otherwise).</p> Source code in <code>redis_robot_comm/redis_client.py</code> <pre><code>def clear_stream(self) -&gt; bool:\n    \"\"\"\n    L\u00f6scht den Objekterkennungs-Stream.\n\n    Clear the object detection stream.\n\n    Returns:\n        bool: True bei Erfolg, False andernfalls. (True if successful, False otherwise).\n    \"\"\"\n    try:\n        result = self.client.delete(self.stream_name)\n        if self.verbose:\n            logger.info(f\"Cleared {self.stream_name} stream: {result}\")\n        return bool(result)\n    except Exception as e:\n        logger.error(f\"Error clearing stream: {e}\")\n        return False\n</code></pre>"},{"location":"api/broker/#redis_robot_comm.redis_client.RedisMessageBroker.get_latest_objects","title":"<code>get_latest_objects(max_age_seconds=2.0)</code>","text":"<p>Ruft die neuesten Objekterkennungen aus dem Stream ab.</p> <p>Retrieve the most recent object detections from the stream.</p> <p>Parameters:</p> Name Type Description Default <code>max_age_seconds</code> <code>float</code> <p>Maximales Alter der abzurufenden Objekte. (Maximum age of objects to retrieve).</p> <code>2.0</code> <p>Returns:</p> Type Description <code>List[ObjectDict]</code> <p>List[ObjectDict]: Liste der erkannten Objekte oder leere Liste, falls keine gefunden wurden oder diese zu alt sind. (List of detected objects, or empty list if none found or too old).</p> <p>Raises:</p> Type Description <code>RedisRetrievalError</code> <p>Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).</p> Source code in <code>redis_robot_comm/redis_client.py</code> <pre><code>def get_latest_objects(self, max_age_seconds: float = 2.0) -&gt; List[ObjectDict]:\n    \"\"\"\n    Ruft die neuesten Objekterkennungen aus dem Stream ab.\n\n    Retrieve the most recent object detections from the stream.\n\n    Args:\n        max_age_seconds (float): Maximales Alter der abzurufenden Objekte. (Maximum age of objects to retrieve).\n\n    Returns:\n        List[ObjectDict]: Liste der erkannten Objekte oder leere Liste, falls keine gefunden wurden oder diese zu alt sind. (List of detected objects, or empty list if none found or too old).\n\n    Raises:\n        RedisRetrievalError: Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).\n    \"\"\"\n    try:\n        # Get the latest message from the stream\n        messages = self.client.xrevrange(self.stream_name, count=1)\n        if not messages:\n            if self.verbose:\n                logger.debug(f\"No messages found in {self.stream_name}\")\n            return []\n\n        # Parse the latest message\n        msg_id, fields = messages[0]\n\n        # Check if message is fresh enough\n        msg_timestamp = float(fields.get(\"timestamp\", \"0\"))\n        current_time = time.time()\n\n        if current_time - msg_timestamp &gt; max_age_seconds:\n            if self.verbose:\n                logger.debug(f\"Latest objects too old: {current_time - msg_timestamp:.2f}s &gt; {max_age_seconds}s\")\n            return []\n\n        # Parse and return objects\n        objects_json = fields.get(\"objects\", \"[]\")\n        objects = json.loads(objects_json)\n        if self.verbose:\n            logger.info(f\"Retrieved {len(objects)} fresh objects\")\n        return cast(List[ObjectDict], objects)\n\n    except RedisError as e:\n        logger.error(f\"Error getting latest objects: {e}\")\n        raise RedisRetrievalError(f\"Failed to retrieve objects: {e}\") from e\n    except Exception as e:\n        logger.error(f\"Unexpected error getting latest objects: {e}\")\n        return []\n</code></pre>"},{"location":"api/broker/#redis_robot_comm.redis_client.RedisMessageBroker.get_objects_in_timerange","title":"<code>get_objects_in_timerange(start_timestamp, end_timestamp=None)</code>","text":"<p>Ruft Objekte ab, die innerhalb eines bestimmten Zeitbereichs ver\u00f6ffentlicht wurden.</p> <p>Retrieve objects published within a specific time range.</p> <p>Parameters:</p> Name Type Description Default <code>start_timestamp</code> <code>float</code> <p>Startzeit als Unix-Zeitstempel. (Start time as Unix timestamp).</p> required <code>end_timestamp</code> <code>Optional[float]</code> <p>Endzeit als Unix-Zeitstempel. Falls None, wird die aktuelle Zeit verwendet. (End time as Unix timestamp. If None, uses current time).</p> <code>None</code> <p>Returns:</p> Type Description <code>List[ObjectDict]</code> <p>List[ObjectDict]: Liste der im Intervall gefundenen Objekte. (List of objects found in the interval).</p> <p>Raises:</p> Type Description <code>RedisRetrievalError</code> <p>Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).</p> Source code in <code>redis_robot_comm/redis_client.py</code> <pre><code>def get_objects_in_timerange(self, start_timestamp: float, end_timestamp: Optional[float] = None) -&gt; List[ObjectDict]:\n    \"\"\"\n    Ruft Objekte ab, die innerhalb eines bestimmten Zeitbereichs ver\u00f6ffentlicht wurden.\n\n    Retrieve objects published within a specific time range.\n\n    Args:\n        start_timestamp (float): Startzeit als Unix-Zeitstempel. (Start time as Unix timestamp).\n        end_timestamp (Optional[float]): Endzeit als Unix-Zeitstempel. Falls None, wird die aktuelle Zeit verwendet. (End time as Unix timestamp. If None, uses current time).\n\n    Returns:\n        List[ObjectDict]: Liste der im Intervall gefundenen Objekte. (List of objects found in the interval).\n\n    Raises:\n        RedisRetrievalError: Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).\n    \"\"\"\n    if end_timestamp is None:\n        end_timestamp = time.time()\n\n    try:\n        # Convert timestamps to Redis stream IDs\n        start_id = f\"{int(start_timestamp * 1000)}-0\"\n        end_id = f\"{int(end_timestamp * 1000)}-0\"\n\n        messages = self.client.xrange(self.stream_name, start_id, end_id)\n\n        all_objects = []\n        for msg_id, fields in messages:\n            objects_json = fields.get(\"objects\", \"[]\")\n            objects = json.loads(objects_json)\n            all_objects.extend(objects)\n\n        if self.verbose:\n            logger.info(f\"Retrieved {len(all_objects)} objects from timerange\")\n        return cast(List[ObjectDict], all_objects)\n\n    except RedisError as e:\n        logger.error(f\"Error getting objects in timerange: {e}\")\n        raise RedisRetrievalError(f\"Failed to retrieve objects in timerange: {e}\") from e\n    except Exception as e:\n        logger.error(f\"Unexpected error getting objects in timerange: {e}\")\n        return []\n</code></pre>"},{"location":"api/broker/#redis_robot_comm.redis_client.RedisMessageBroker.get_stream_info","title":"<code>get_stream_info()</code>","text":"<p>Ruft Informationen \u00fcber den Redis-Stream ab.</p> <p>Retrieve information about the Redis stream.</p> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Optional[Dict[str, Any]]: Dictionary mit Stream-Informationen oder None, falls ein Fehler auftritt. (Dictionary with stream info, or None if an error occurs).</p> Source code in <code>redis_robot_comm/redis_client.py</code> <pre><code>def get_stream_info(self) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Ruft Informationen \u00fcber den Redis-Stream ab.\n\n    Retrieve information about the Redis stream.\n\n    Returns:\n        Optional[Dict[str, Any]]: Dictionary mit Stream-Informationen oder None, falls ein Fehler auftritt. (Dictionary with stream info, or None if an error occurs).\n    \"\"\"\n    try:\n        info = self.client.xinfo_stream(self.stream_name)\n        if self.verbose:\n            logger.info(f\"Stream info: {info}\")\n        return cast(Optional[Dict[str, Any]], info)\n    except Exception as e:\n        logger.error(f\"Error getting stream info: {e}\")\n        return None\n</code></pre>"},{"location":"api/broker/#redis_robot_comm.redis_client.RedisMessageBroker.publish_objects","title":"<code>publish_objects(objects, camera_pose=None, maxlen=500)</code>","text":"<p>Ver\u00f6ffentlicht erkannte Objekte im Redis-Stream.</p> <p>Publish detected objects to the Redis stream.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>List[ObjectDict]</code> <p>Liste von Dictionaries der erkannten Objekte. (List of detected object dictionaries).</p> required <code>camera_pose</code> <code>Optional[CameraPose]</code> <p>Optionale Informationen zur Kamerapose. (Optional camera pose information).</p> <code>None</code> <code>maxlen</code> <code>int</code> <p>Maximale Stream-L\u00e4nge (\u00e4ltere Eintr\u00e4ge werden gek\u00fcrzt). (Maximum stream length (older entries are trimmed)).</p> <code>500</code> <p>Returns:</p> Type Description <code>Optional[StreamID]</code> <p>Optional[StreamID]: ID des Redis-Stream-Eintrags oder None, wenn die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).</p> <p>Raises:</p> Type Description <code>RedisPublishError</code> <p>Wenn die Ver\u00f6ffentlichung bei Redis fehlschl\u00e4gt. (If publishing to Redis fails).</p> Source code in <code>redis_robot_comm/redis_client.py</code> <pre><code>@retry_on_connection_error(max_attempts=3, delay=0.5)\ndef publish_objects(\n    self,\n    objects: List[ObjectDict],\n    camera_pose: Optional[CameraPose] = None,\n    maxlen: int = 500,\n) -&gt; Optional[StreamID]:\n    \"\"\"\n    Ver\u00f6ffentlicht erkannte Objekte im Redis-Stream.\n\n    Publish detected objects to the Redis stream.\n\n    Args:\n        objects (List[ObjectDict]): Liste von Dictionaries der erkannten Objekte. (List of detected object dictionaries).\n        camera_pose (Optional[CameraPose]): Optionale Informationen zur Kamerapose. (Optional camera pose information).\n        maxlen (int): Maximale Stream-L\u00e4nge (\u00e4ltere Eintr\u00e4ge werden gek\u00fcrzt). (Maximum stream length (older entries are trimmed)).\n\n    Returns:\n        Optional[StreamID]: ID des Redis-Stream-Eintrags oder None, wenn die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).\n\n    Raises:\n        RedisPublishError: Wenn die Ver\u00f6ffentlichung bei Redis fehlschl\u00e4gt. (If publishing to Redis fails).\n    \"\"\"\n    validate_objects(objects)\n\n    message = {\n        \"timestamp\": str(time.time()),\n        \"objects\": json.dumps(objects),\n        \"camera_pose\": json.dumps(camera_pose or {}),\n    }\n\n    try:\n        result = self.client.xadd(\n            self.stream_name,\n            message,\n            maxlen=maxlen,\n            approximate=True,\n        )\n\n        if self.verbose:\n            logger.info(f\"Published {len(objects)} objects to {self.stream_name}: {result}\")\n        return cast(Optional[StreamID], result)\n    except RedisError as e:\n        logger.error(f\"Error publishing objects: {e}\")\n        raise RedisPublishError(f\"Failed to publish objects: {e}\") from e\n    except Exception as e:\n        logger.error(f\"Unexpected error publishing objects: {e}\")\n        return None\n</code></pre>"},{"location":"api/broker/#redis_robot_comm.redis_client.RedisMessageBroker.subscribe_objects","title":"<code>subscribe_objects(callback)</code>","text":"<p>Startet ein blockierendes Abonnement f\u00fcr Objekterkennungen.</p> <p>Start a blocking subscription for object detections.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Dict[str, Any]], None]</code> <p>Funktion, die ein Dictionary mit 'objects', 'camera_pose' und 'timestamp' erh\u00e4lt. (Function receiving a dictionary with 'objects', 'camera_pose', and 'timestamp').</p> required Source code in <code>redis_robot_comm/redis_client.py</code> <pre><code>def subscribe_objects(self, callback: Callable[[Dict[str, Any]], None]) -&gt; None:\n    \"\"\"\n    Startet ein blockierendes Abonnement f\u00fcr Objekterkennungen.\n\n    Start a blocking subscription for object detections.\n\n    Args:\n        callback (Callable[[Dict[str, Any]], None]): Funktion, die ein Dictionary mit 'objects', 'camera_pose' und 'timestamp' erh\u00e4lt. (Function receiving a dictionary with 'objects', 'camera_pose', and 'timestamp').\n    \"\"\"\n    if self.verbose:\n        logger.info(f\"Starting to listen for object detections on {self.stream_name}...\")\n    last_id = \"$\"  # Start from newest\n\n    try:\n        while True:\n            # Block for up to 1 second waiting for new messages\n            messages = self.client.xread({self.stream_name: last_id}, block=1000)\n\n            for stream, msgs in messages:\n                for msg_id, fields in msgs:\n                    try:\n                        # Parse objects from JSON\n                        objects_json = fields.get(\"objects\", \"[]\")\n                        objects = json.loads(objects_json)\n\n                        # Parse camera pose if available\n                        camera_pose_json = fields.get(\"camera_pose\", \"{}\")\n                        camera_pose = json.loads(camera_pose_json)\n\n                        # Call callback with parsed data\n                        callback(\n                            {\n                                \"objects\": objects,\n                                \"camera_pose\": camera_pose,\n                                \"timestamp\": float(fields.get(\"timestamp\", \"0\")),\n                            }\n                        )\n\n                        last_id = msg_id\n\n                    except Exception as e:\n                        logger.error(f\"Error processing message {msg_id}: {e}\")\n\n    except KeyboardInterrupt:\n        logger.info(\"Stopped listening for object detections\")\n    except RedisError as e:\n        logger.error(f\"Redis error in subscribe_objects: {e}\")\n        raise RedisRetrievalError(f\"Subscription failed: {e}\") from e\n    except Exception as e:\n        logger.error(f\"Unexpected error in subscribe_objects: {e}\")\n</code></pre>"},{"location":"api/broker/#redis_robot_comm.redis_client.RedisMessageBroker.test_connection","title":"<code>test_connection()</code>","text":"<p>Testet die Verbindung zum Redis-Server.</p> <p>Test the connection to the Redis server.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True, wenn die Verbindung erfolgreich ist, andernfalls False. (True if connection is successful, False otherwise).</p> Source code in <code>redis_robot_comm/redis_client.py</code> <pre><code>def test_connection(self) -&gt; bool:\n    \"\"\"\n    Testet die Verbindung zum Redis-Server.\n\n    Test the connection to the Redis server.\n\n    Returns:\n        bool: True, wenn die Verbindung erfolgreich ist, andernfalls False. (True if connection is successful, False otherwise).\n    \"\"\"\n    try:\n        pong = self.client.ping()\n        if self.verbose:\n            logger.info(f\"Redis connection test: {'OK' if pong else 'FAILED'}\")\n        return bool(pong)\n    except Exception as e:\n        logger.error(f\"Redis connection failed: {e}\")\n        return False\n</code></pre>"},{"location":"api/labels/","title":"RedisLabelManager","text":""},{"location":"api/labels/#redis_robot_comm.redis_label_manager.RedisLabelManager","title":"<code>redis_robot_comm.redis_label_manager.RedisLabelManager</code>","text":"<p>Verwaltet erkennbare Objektlabels \u00fcber Redis-Streams.</p> <p>Manages detectable object labels via Redis streams.</p> <p>Publisher (vision_detect_segment): Ver\u00f6ffentlichen verf\u00fcgbare Labels, wenn diese sich \u00e4ndern. (Publish available labels when they change). Consumer (robot_environment): Abonnieren, um aktuelle erkennbare Labels zu erhalten. (Subscribe to get current detectable labels).</p> Source code in <code>redis_robot_comm/redis_label_manager.py</code> <pre><code>class RedisLabelManager:\n    \"\"\"\n    Verwaltet erkennbare Objektlabels \u00fcber Redis-Streams.\n\n    Manages detectable object labels via Redis streams.\n\n    Publisher (vision_detect_segment): Ver\u00f6ffentlichen verf\u00fcgbare Labels, wenn diese sich \u00e4ndern. (Publish available labels when they change).\n    Consumer (robot_environment): Abonnieren, um aktuelle erkennbare Labels zu erhalten. (Subscribe to get current detectable labels).\n    \"\"\"\n\n    def __init__(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        stream_name: str = \"detectable_labels\",\n        config: Optional[RedisConfig] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialisiert den Label-Manager.\n\n        Initialize the label manager.\n\n        Args:\n            host (Optional[str]): Redis-Server-Host. (Redis server host).\n            port (Optional[int]): Redis-Server-Port. (Redis server port).\n            stream_name (str): Name des Redis-Streams f\u00fcr Labels. (Name of the Redis stream for labels).\n            config (Optional[RedisConfig]): Optionale RedisConfig-Instanz. (Optional RedisConfig instance).\n\n        Raises:\n            RedisConnectionError: Wenn die Verbindung zu Redis fehlschl\u00e4gt. (If connection to Redis fails).\n        \"\"\"\n        if config is None:\n            config = get_redis_config()\n\n        # Override config with explicit parameters if provided\n        host = host or config.host\n        port = port or config.port\n\n        validate_stream_name(stream_name)\n        self.stream_name: str = stream_name\n        self.verbose: bool = False\n        try:\n            self.client = redis.Redis(\n                host=host,\n                port=port,\n                db=config.db,\n                password=config.password,\n                socket_timeout=config.socket_timeout,\n                socket_connect_timeout=config.socket_connect_timeout,\n                retry_on_timeout=config.retry_on_timeout,\n                max_connections=config.max_connections,\n                decode_responses=True,\n            )\n            self.client.ping()\n        except RedisError as e:\n            raise RedisConnectionError(f\"Failed to connect to Redis: {e}\") from e\n\n    @retry_on_connection_error(max_attempts=3, delay=0.5)\n    def publish_labels(self, labels: LabelList, metadata: Optional[Dict[str, Any]] = None) -&gt; Optional[StreamID]:\n        \"\"\"\n        Ver\u00f6ffentlicht die aktuelle Liste der erkennbaren Objektlabels.\n\n        Publish the current list of detectable object labels.\n\n        Args:\n            labels (LabelList): Liste der Objektlabel-Strings. (List of object label strings).\n            metadata (Optional[Dict[str, Any]]): Optionale Metadaten (z. B. model_id, Zeitstempel). (Optional metadata (e.g., model_id, timestamp)).\n\n        Returns:\n            Optional[StreamID]: Redis-Stream-Eintrags-ID oder None, falls die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).\n\n        Raises:\n            RedisPublishError: Wenn die Ver\u00f6ffentlichung bei Redis fehlschl\u00e4gt. (If publishing to Redis fails).\n        \"\"\"\n        message = {\n            \"timestamp\": str(time.time()),\n            \"labels\": json.dumps(labels),\n            \"label_count\": str(len(labels)),\n        }\n\n        if metadata:\n            message[\"metadata\"] = json.dumps(metadata)\n\n        try:\n            # Keep only latest entry (maxlen=1)\n            stream_id = self.client.xadd(self.stream_name, message, maxlen=1)\n\n            if self.verbose:\n                logger.info(f\"Published {len(labels)} labels to Redis: {stream_id}\")\n\n            return cast(Optional[StreamID], stream_id)\n\n        except RedisError as e:\n            logger.error(f\"Error publishing labels to Redis: {e}\")\n            raise RedisPublishError(f\"Failed to publish labels: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Unexpected error publishing labels: {e}\")\n            return None\n\n    def get_latest_labels(self, timeout_seconds: float = 5.0) -&gt; Optional[LabelList]:\n        \"\"\"\n        Ruft die aktuellste Liste der erkennbaren Labels ab.\n\n        Get the most recent list of detectable labels.\n\n        Args:\n            timeout_seconds (float): Maximales Alter der zu akzeptierenden Labels. (Maximum age of labels to accept).\n\n        Returns:\n            Optional[LabelList]: Liste der Label-Strings oder None, falls nicht verf\u00fcgbar oder zu alt. (List of label strings, or None if not available or too old).\n\n        Raises:\n            RedisRetrievalError: Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).\n        \"\"\"\n        try:\n            # Get the latest message\n            messages = self.client.xrevrange(self.stream_name, count=1)\n\n            if not messages:\n                if self.verbose:\n                    logger.debug(f\"No labels found in {self.stream_name}\")\n                return None\n\n            msg_id, fields = messages[0]\n\n            # Check if labels are fresh enough\n            msg_timestamp = float(fields.get(\"timestamp\", \"0\"))\n            current_time = time.time()\n\n            if current_time - msg_timestamp &gt; timeout_seconds:\n                if self.verbose:\n                    logger.debug(f\"Labels too old: {current_time - msg_timestamp:.1f}s\")\n                return None\n\n            # Parse and return labels\n            labels_json = fields.get(\"labels\", \"[]\")\n            labels = json.loads(labels_json)\n\n            if self.verbose:\n                logger.info(f\"Retrieved {len(labels)} labels\")\n\n            return cast(Optional[LabelList], labels)\n\n        except RedisError as e:\n            logger.error(f\"Error getting labels from Redis: {e}\")\n            raise RedisRetrievalError(f\"Failed to retrieve labels: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Unexpected error getting labels: {e}\")\n            return None\n\n    def add_label(self, new_label: str) -&gt; bool:\n        \"\"\"\n        F\u00fcgt der aktuellen Liste ein neues Label hinzu und ver\u00f6ffentlicht diese neu.\n\n        Add a new label to the current list and republish.\n\n        Args:\n            new_label (str): Hinzuzuf\u00fcgendes Label. (Label to add).\n\n        Returns:\n            bool: True bei Erfolg, False andernfalls. (True if successful, False otherwise).\n        \"\"\"\n        try:\n            # Get current labels\n            current_labels = self.get_latest_labels(timeout_seconds=60.0)\n\n            if current_labels is None:\n                if self.verbose:\n                    logger.info(\"No existing labels found, creating new list\")\n                current_labels = []\n\n            # Add new label if not already present\n            if new_label.lower() not in [lbl.lower() for lbl in current_labels]:\n                current_labels.append(new_label.lower())\n\n                # Republish updated list\n                result = self.publish_labels(current_labels, metadata={\"action\": \"add\", \"added_label\": new_label})\n                if result is None:\n                    return False\n\n                if self.verbose:\n                    logger.info(f\"Added label: {new_label}\")\n\n                return True\n            else:\n                if self.verbose:\n                    logger.info(f\"Label already exists: {new_label}\")\n                return False\n\n        except Exception as e:\n            logger.error(f\"Error adding label: {e}\")\n            return False\n\n    def subscribe_to_label_updates(\n        self,\n        callback: Callable[[LabelList, Dict[str, Any]], None],\n        block_ms: int = 1000,\n    ) -&gt; None:\n        \"\"\"\n        Abonniert Label-Updates und ruft den Callback auf, wenn sich diese \u00e4ndern.\n\n        Subscribe to label updates and call callback when they change.\n\n        Args:\n            callback (Callable[[LabelList, Dict[str, Any]], None]): Funktion, die (labels, metadata) erh\u00e4lt. (Function receiving (labels, metadata)).\n            block_ms (int): Blockier-Timeout in Millisekunden. (Blocking timeout in milliseconds).\n\n        Raises:\n            RedisRetrievalError: Wenn das Abonnement fehlschl\u00e4gt. (If subscription fails).\n        \"\"\"\n        last_id = \"$\"  # Start from newest\n\n        if self.verbose:\n            logger.info(f\"Subscribing to label updates on {self.stream_name}...\")\n\n        try:\n            while True:\n                messages = self.client.xread({self.stream_name: last_id}, block=block_ms, count=1)\n\n                for stream, msgs in messages:\n                    for msg_id, fields in msgs:\n                        try:\n                            labels_json = fields.get(\"labels\", \"[]\")\n                            labels = json.loads(labels_json)\n\n                            metadata = {}\n                            if \"metadata\" in fields:\n                                metadata = json.loads(fields[\"metadata\"])\n\n                            callback(labels, metadata)\n                            last_id = msg_id\n\n                        except Exception as e:\n                            logger.error(f\"Error processing label update: {e}\")\n\n        except KeyboardInterrupt:\n            logger.info(\"Stopped subscribing to labels\")\n        except RedisError as e:\n            logger.error(f\"Redis error in label subscription: {e}\")\n            raise RedisRetrievalError(f\"Label subscription failed: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Unexpected error in label subscription: {e}\")\n\n    def clear_stream(self) -&gt; bool:\n        \"\"\"\n        L\u00f6scht den Labels-Stream.\n\n        Clear the labels stream.\n\n        Returns:\n            bool: True bei Erfolg, False andernfalls. (True if successful, False otherwise).\n        \"\"\"\n        try:\n            result = self.client.delete(self.stream_name)\n            if self.verbose:\n                logger.info(f\"Cleared labels stream: {result}\")\n            return bool(result)\n        except Exception as e:\n            logger.error(f\"Error clearing stream: {e}\")\n            return False\n</code></pre>"},{"location":"api/labels/#redis_robot_comm.redis_label_manager.RedisLabelManager-functions","title":"Functions","text":""},{"location":"api/labels/#redis_robot_comm.redis_label_manager.RedisLabelManager.__init__","title":"<code>__init__(host=None, port=None, stream_name='detectable_labels', config=None)</code>","text":"<p>Initialisiert den Label-Manager.</p> <p>Initialize the label manager.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>Optional[str]</code> <p>Redis-Server-Host. (Redis server host).</p> <code>None</code> <code>port</code> <code>Optional[int]</code> <p>Redis-Server-Port. (Redis server port).</p> <code>None</code> <code>stream_name</code> <code>str</code> <p>Name des Redis-Streams f\u00fcr Labels. (Name of the Redis stream for labels).</p> <code>'detectable_labels'</code> <code>config</code> <code>Optional[RedisConfig]</code> <p>Optionale RedisConfig-Instanz. (Optional RedisConfig instance).</p> <code>None</code> <p>Raises:</p> Type Description <code>RedisConnectionError</code> <p>Wenn die Verbindung zu Redis fehlschl\u00e4gt. (If connection to Redis fails).</p> Source code in <code>redis_robot_comm/redis_label_manager.py</code> <pre><code>def __init__(\n    self,\n    host: Optional[str] = None,\n    port: Optional[int] = None,\n    stream_name: str = \"detectable_labels\",\n    config: Optional[RedisConfig] = None,\n) -&gt; None:\n    \"\"\"\n    Initialisiert den Label-Manager.\n\n    Initialize the label manager.\n\n    Args:\n        host (Optional[str]): Redis-Server-Host. (Redis server host).\n        port (Optional[int]): Redis-Server-Port. (Redis server port).\n        stream_name (str): Name des Redis-Streams f\u00fcr Labels. (Name of the Redis stream for labels).\n        config (Optional[RedisConfig]): Optionale RedisConfig-Instanz. (Optional RedisConfig instance).\n\n    Raises:\n        RedisConnectionError: Wenn die Verbindung zu Redis fehlschl\u00e4gt. (If connection to Redis fails).\n    \"\"\"\n    if config is None:\n        config = get_redis_config()\n\n    # Override config with explicit parameters if provided\n    host = host or config.host\n    port = port or config.port\n\n    validate_stream_name(stream_name)\n    self.stream_name: str = stream_name\n    self.verbose: bool = False\n    try:\n        self.client = redis.Redis(\n            host=host,\n            port=port,\n            db=config.db,\n            password=config.password,\n            socket_timeout=config.socket_timeout,\n            socket_connect_timeout=config.socket_connect_timeout,\n            retry_on_timeout=config.retry_on_timeout,\n            max_connections=config.max_connections,\n            decode_responses=True,\n        )\n        self.client.ping()\n    except RedisError as e:\n        raise RedisConnectionError(f\"Failed to connect to Redis: {e}\") from e\n</code></pre>"},{"location":"api/labels/#redis_robot_comm.redis_label_manager.RedisLabelManager.add_label","title":"<code>add_label(new_label)</code>","text":"<p>F\u00fcgt der aktuellen Liste ein neues Label hinzu und ver\u00f6ffentlicht diese neu.</p> <p>Add a new label to the current list and republish.</p> <p>Parameters:</p> Name Type Description Default <code>new_label</code> <code>str</code> <p>Hinzuzuf\u00fcgendes Label. (Label to add).</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True bei Erfolg, False andernfalls. (True if successful, False otherwise).</p> Source code in <code>redis_robot_comm/redis_label_manager.py</code> <pre><code>def add_label(self, new_label: str) -&gt; bool:\n    \"\"\"\n    F\u00fcgt der aktuellen Liste ein neues Label hinzu und ver\u00f6ffentlicht diese neu.\n\n    Add a new label to the current list and republish.\n\n    Args:\n        new_label (str): Hinzuzuf\u00fcgendes Label. (Label to add).\n\n    Returns:\n        bool: True bei Erfolg, False andernfalls. (True if successful, False otherwise).\n    \"\"\"\n    try:\n        # Get current labels\n        current_labels = self.get_latest_labels(timeout_seconds=60.0)\n\n        if current_labels is None:\n            if self.verbose:\n                logger.info(\"No existing labels found, creating new list\")\n            current_labels = []\n\n        # Add new label if not already present\n        if new_label.lower() not in [lbl.lower() for lbl in current_labels]:\n            current_labels.append(new_label.lower())\n\n            # Republish updated list\n            result = self.publish_labels(current_labels, metadata={\"action\": \"add\", \"added_label\": new_label})\n            if result is None:\n                return False\n\n            if self.verbose:\n                logger.info(f\"Added label: {new_label}\")\n\n            return True\n        else:\n            if self.verbose:\n                logger.info(f\"Label already exists: {new_label}\")\n            return False\n\n    except Exception as e:\n        logger.error(f\"Error adding label: {e}\")\n        return False\n</code></pre>"},{"location":"api/labels/#redis_robot_comm.redis_label_manager.RedisLabelManager.clear_stream","title":"<code>clear_stream()</code>","text":"<p>L\u00f6scht den Labels-Stream.</p> <p>Clear the labels stream.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True bei Erfolg, False andernfalls. (True if successful, False otherwise).</p> Source code in <code>redis_robot_comm/redis_label_manager.py</code> <pre><code>def clear_stream(self) -&gt; bool:\n    \"\"\"\n    L\u00f6scht den Labels-Stream.\n\n    Clear the labels stream.\n\n    Returns:\n        bool: True bei Erfolg, False andernfalls. (True if successful, False otherwise).\n    \"\"\"\n    try:\n        result = self.client.delete(self.stream_name)\n        if self.verbose:\n            logger.info(f\"Cleared labels stream: {result}\")\n        return bool(result)\n    except Exception as e:\n        logger.error(f\"Error clearing stream: {e}\")\n        return False\n</code></pre>"},{"location":"api/labels/#redis_robot_comm.redis_label_manager.RedisLabelManager.get_latest_labels","title":"<code>get_latest_labels(timeout_seconds=5.0)</code>","text":"<p>Ruft die aktuellste Liste der erkennbaren Labels ab.</p> <p>Get the most recent list of detectable labels.</p> <p>Parameters:</p> Name Type Description Default <code>timeout_seconds</code> <code>float</code> <p>Maximales Alter der zu akzeptierenden Labels. (Maximum age of labels to accept).</p> <code>5.0</code> <p>Returns:</p> Type Description <code>Optional[LabelList]</code> <p>Optional[LabelList]: Liste der Label-Strings oder None, falls nicht verf\u00fcgbar oder zu alt. (List of label strings, or None if not available or too old).</p> <p>Raises:</p> Type Description <code>RedisRetrievalError</code> <p>Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).</p> Source code in <code>redis_robot_comm/redis_label_manager.py</code> <pre><code>def get_latest_labels(self, timeout_seconds: float = 5.0) -&gt; Optional[LabelList]:\n    \"\"\"\n    Ruft die aktuellste Liste der erkennbaren Labels ab.\n\n    Get the most recent list of detectable labels.\n\n    Args:\n        timeout_seconds (float): Maximales Alter der zu akzeptierenden Labels. (Maximum age of labels to accept).\n\n    Returns:\n        Optional[LabelList]: Liste der Label-Strings oder None, falls nicht verf\u00fcgbar oder zu alt. (List of label strings, or None if not available or too old).\n\n    Raises:\n        RedisRetrievalError: Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).\n    \"\"\"\n    try:\n        # Get the latest message\n        messages = self.client.xrevrange(self.stream_name, count=1)\n\n        if not messages:\n            if self.verbose:\n                logger.debug(f\"No labels found in {self.stream_name}\")\n            return None\n\n        msg_id, fields = messages[0]\n\n        # Check if labels are fresh enough\n        msg_timestamp = float(fields.get(\"timestamp\", \"0\"))\n        current_time = time.time()\n\n        if current_time - msg_timestamp &gt; timeout_seconds:\n            if self.verbose:\n                logger.debug(f\"Labels too old: {current_time - msg_timestamp:.1f}s\")\n            return None\n\n        # Parse and return labels\n        labels_json = fields.get(\"labels\", \"[]\")\n        labels = json.loads(labels_json)\n\n        if self.verbose:\n            logger.info(f\"Retrieved {len(labels)} labels\")\n\n        return cast(Optional[LabelList], labels)\n\n    except RedisError as e:\n        logger.error(f\"Error getting labels from Redis: {e}\")\n        raise RedisRetrievalError(f\"Failed to retrieve labels: {e}\") from e\n    except Exception as e:\n        logger.error(f\"Unexpected error getting labels: {e}\")\n        return None\n</code></pre>"},{"location":"api/labels/#redis_robot_comm.redis_label_manager.RedisLabelManager.publish_labels","title":"<code>publish_labels(labels, metadata=None)</code>","text":"<p>Ver\u00f6ffentlicht die aktuelle Liste der erkennbaren Objektlabels.</p> <p>Publish the current list of detectable object labels.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>LabelList</code> <p>Liste der Objektlabel-Strings. (List of object label strings).</p> required <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Optionale Metadaten (z. B. model_id, Zeitstempel). (Optional metadata (e.g., model_id, timestamp)).</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[StreamID]</code> <p>Optional[StreamID]: Redis-Stream-Eintrags-ID oder None, falls die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).</p> <p>Raises:</p> Type Description <code>RedisPublishError</code> <p>Wenn die Ver\u00f6ffentlichung bei Redis fehlschl\u00e4gt. (If publishing to Redis fails).</p> Source code in <code>redis_robot_comm/redis_label_manager.py</code> <pre><code>@retry_on_connection_error(max_attempts=3, delay=0.5)\ndef publish_labels(self, labels: LabelList, metadata: Optional[Dict[str, Any]] = None) -&gt; Optional[StreamID]:\n    \"\"\"\n    Ver\u00f6ffentlicht die aktuelle Liste der erkennbaren Objektlabels.\n\n    Publish the current list of detectable object labels.\n\n    Args:\n        labels (LabelList): Liste der Objektlabel-Strings. (List of object label strings).\n        metadata (Optional[Dict[str, Any]]): Optionale Metadaten (z. B. model_id, Zeitstempel). (Optional metadata (e.g., model_id, timestamp)).\n\n    Returns:\n        Optional[StreamID]: Redis-Stream-Eintrags-ID oder None, falls die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).\n\n    Raises:\n        RedisPublishError: Wenn die Ver\u00f6ffentlichung bei Redis fehlschl\u00e4gt. (If publishing to Redis fails).\n    \"\"\"\n    message = {\n        \"timestamp\": str(time.time()),\n        \"labels\": json.dumps(labels),\n        \"label_count\": str(len(labels)),\n    }\n\n    if metadata:\n        message[\"metadata\"] = json.dumps(metadata)\n\n    try:\n        # Keep only latest entry (maxlen=1)\n        stream_id = self.client.xadd(self.stream_name, message, maxlen=1)\n\n        if self.verbose:\n            logger.info(f\"Published {len(labels)} labels to Redis: {stream_id}\")\n\n        return cast(Optional[StreamID], stream_id)\n\n    except RedisError as e:\n        logger.error(f\"Error publishing labels to Redis: {e}\")\n        raise RedisPublishError(f\"Failed to publish labels: {e}\") from e\n    except Exception as e:\n        logger.error(f\"Unexpected error publishing labels: {e}\")\n        return None\n</code></pre>"},{"location":"api/labels/#redis_robot_comm.redis_label_manager.RedisLabelManager.subscribe_to_label_updates","title":"<code>subscribe_to_label_updates(callback, block_ms=1000)</code>","text":"<p>Abonniert Label-Updates und ruft den Callback auf, wenn sich diese \u00e4ndern.</p> <p>Subscribe to label updates and call callback when they change.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[LabelList, Dict[str, Any]], None]</code> <p>Funktion, die (labels, metadata) erh\u00e4lt. (Function receiving (labels, metadata)).</p> required <code>block_ms</code> <code>int</code> <p>Blockier-Timeout in Millisekunden. (Blocking timeout in milliseconds).</p> <code>1000</code> <p>Raises:</p> Type Description <code>RedisRetrievalError</code> <p>Wenn das Abonnement fehlschl\u00e4gt. (If subscription fails).</p> Source code in <code>redis_robot_comm/redis_label_manager.py</code> <pre><code>def subscribe_to_label_updates(\n    self,\n    callback: Callable[[LabelList, Dict[str, Any]], None],\n    block_ms: int = 1000,\n) -&gt; None:\n    \"\"\"\n    Abonniert Label-Updates und ruft den Callback auf, wenn sich diese \u00e4ndern.\n\n    Subscribe to label updates and call callback when they change.\n\n    Args:\n        callback (Callable[[LabelList, Dict[str, Any]], None]): Funktion, die (labels, metadata) erh\u00e4lt. (Function receiving (labels, metadata)).\n        block_ms (int): Blockier-Timeout in Millisekunden. (Blocking timeout in milliseconds).\n\n    Raises:\n        RedisRetrievalError: Wenn das Abonnement fehlschl\u00e4gt. (If subscription fails).\n    \"\"\"\n    last_id = \"$\"  # Start from newest\n\n    if self.verbose:\n        logger.info(f\"Subscribing to label updates on {self.stream_name}...\")\n\n    try:\n        while True:\n            messages = self.client.xread({self.stream_name: last_id}, block=block_ms, count=1)\n\n            for stream, msgs in messages:\n                for msg_id, fields in msgs:\n                    try:\n                        labels_json = fields.get(\"labels\", \"[]\")\n                        labels = json.loads(labels_json)\n\n                        metadata = {}\n                        if \"metadata\" in fields:\n                            metadata = json.loads(fields[\"metadata\"])\n\n                        callback(labels, metadata)\n                        last_id = msg_id\n\n                    except Exception as e:\n                        logger.error(f\"Error processing label update: {e}\")\n\n    except KeyboardInterrupt:\n        logger.info(\"Stopped subscribing to labels\")\n    except RedisError as e:\n        logger.error(f\"Redis error in label subscription: {e}\")\n        raise RedisRetrievalError(f\"Label subscription failed: {e}\") from e\n    except Exception as e:\n        logger.error(f\"Unexpected error in label subscription: {e}\")\n</code></pre>"},{"location":"api/streamer/","title":"RedisImageStreamer","text":""},{"location":"api/streamer/#redis_robot_comm.redis_image_streamer.RedisImageStreamer","title":"<code>redis_robot_comm.redis_image_streamer.RedisImageStreamer</code>","text":"<p>Ein Redis-basierter Stream, der OpenCV-Bilder beliebiger Gr\u00f6\u00dfe ver\u00f6ffentlichen und empfangen kann.</p> <p>A Redis-backed stream that can publish and consume OpenCV images of arbitrary size.</p> <p>Die Klasse serialisiert ein Bild (entweder als Rohdaten oder JPEG) und speichert es in einem Redis-Stream. Jeder Eintrag enth\u00e4lt Metadaten wie die Bildform, den Datentyp und optionale benutzerdefinierte Felder.</p> <p>The class serializes an image (either as raw bytes or JPEG) and stores it in a Redis stream. Each entry contains metadata such as the image shape, data type, and optional custom fields.</p> Source code in <code>redis_robot_comm/redis_image_streamer.py</code> <pre><code>class RedisImageStreamer:\n    \"\"\"\n    Ein Redis-basierter Stream, der OpenCV-Bilder beliebiger Gr\u00f6\u00dfe ver\u00f6ffentlichen und empfangen kann.\n\n    A Redis-backed stream that can publish and consume OpenCV images of arbitrary size.\n\n    Die Klasse serialisiert ein Bild (entweder als Rohdaten oder JPEG) und speichert es in einem Redis-Stream.\n    Jeder Eintrag enth\u00e4lt Metadaten wie die Bildform, den Datentyp und optionale benutzerdefinierte Felder.\n\n    The class serializes an image (either as raw bytes or JPEG) and stores it in a Redis stream.\n    Each entry contains metadata such as the image shape, data type, and optional custom fields.\n    \"\"\"\n\n    def __init__(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        stream_name: str = \"robot_camera\",\n        config: Optional[RedisConfig] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialisiert den Redis Image Streamer.\n\n        Initialize the Redis image streamer.\n\n        Args:\n            host (Optional[str]): Hostname oder IP-Adresse des Redis-Servers. (Redis server hostname or IP address).\n            port (Optional[int]): Port des Redis-Servers. (Redis server port).\n            stream_name (str): Name des Streams, der die Bild-Frames enthalten wird. (Name of the stream that will hold the image frames).\n            config (Optional[RedisConfig]): Optionale RedisConfig-Instanz. (Optional RedisConfig instance).\n\n        Raises:\n            RedisConnectionError: Wenn die Verbindung zu Redis fehlschl\u00e4gt. (If connection to Redis fails).\n        \"\"\"\n        if config is None:\n            config = get_redis_config()\n\n        # Override config with explicit parameters if provided\n        host = host or config.host\n        port = port or config.port\n\n        validate_stream_name(stream_name)\n        self.stream_name: str = stream_name\n        self.verbose: bool = False\n        try:\n            self.client = redis.Redis(\n                host=host,\n                port=port,\n                db=config.db,\n                password=config.password,\n                socket_timeout=config.socket_timeout,\n                socket_connect_timeout=config.socket_connect_timeout,\n                retry_on_timeout=config.retry_on_timeout,\n                max_connections=config.max_connections,\n                decode_responses=True,\n            )\n            self.client.ping()\n        except RedisError as e:\n            raise RedisConnectionError(f\"Failed to connect to Redis: {e}\") from e\n\n    @retry_on_connection_error(max_attempts=3, delay=0.5)\n    def publish_image(\n        self,\n        image: ImageArray,\n        metadata: Optional[ImageMetadata] = None,\n        compress_jpeg: bool = True,\n        quality: int = 80,\n        maxlen: int = 5,\n    ) -&gt; StreamID:\n        \"\"\"\n        Ver\u00f6ffentlicht einen einzelnen Bild-Frame im Redis-Stream.\n\n        Publish a single image frame to the Redis stream.\n\n        Args:\n            image (ImageArray): OpenCV-Bild-Array (HxWxC oder HxW f\u00fcr Graustufen). (OpenCV image array (H\u00d7W\u00d7C or H\u00d7W for grayscale)).\n            metadata (Optional[ImageMetadata]): Beliebige Metadaten, die zusammen mit dem Frame gespeichert werden. (Arbitrary metadata stored alongside the frame).\n            compress_jpeg (bool): Gibt an, ob das Bild in das JPEG-Format komprimiert werden soll. (Whether to compress the image to JPEG).\n            quality (int): JPEG-Kompressionsqualit\u00e4t (1-100). (JPEG compression quality (1-100)).\n            maxlen (int): Maximale Anzahl von Eintr\u00e4gen, die im Stream gehalten werden sollen. (Maximum number of entries to keep in the stream).\n\n        Returns:\n            StreamID: Die eindeutige Redis-Eintrags-ID. (The unique Redis entry ID).\n\n        Raises:\n            InvalidImageError: Wenn das bereitgestellte Bild ung\u00fcltig ist. (If the supplied image is invalid).\n            RedisPublishError: Wenn die Ver\u00f6ffentlichung bei Redis fehlschl\u00e4gt. (If publishing to Redis fails).\n        \"\"\"\n        try:\n            validate_image(image)\n        except InvalidImageError as e:\n            logger.error(f\"Image validation failed: {e}\")\n            raise\n\n        timestamp = time.time()\n\n        # Handle different image sizes dynamically\n        height, width = image.shape[:2]\n        channels = image.shape[2] if len(image.shape) == 3 else 1\n\n        if compress_jpeg:\n            # Compress to JPEG\n            success, buffer = cv2.imencode(\".jpg\", image, [cv2.IMWRITE_JPEG_QUALITY, quality])\n            if not success:\n                raise InvalidImageError(\"Failed to compress image to JPEG\")\n            image_data = base64.b64encode(buffer).decode(\"utf-8\")\n            format_type = \"jpeg\"\n            compressed_size = len(buffer)\n        else:\n            # Raw image data\n            image_data = base64.b64encode(image.tobytes()).decode(\"utf-8\")\n            format_type = \"raw\"\n            compressed_size = image.nbytes\n\n        # Prepare message with dynamic image info\n        message = {\n            \"timestamp\": str(timestamp),\n            \"image_data\": image_data,\n            \"format\": format_type,\n            \"width\": str(width),\n            \"height\": str(height),\n            \"channels\": str(channels),\n            \"dtype\": str(image.dtype),\n            \"compressed_size\": str(compressed_size),\n            \"original_size\": str(image.nbytes),\n        }\n\n        # Add optional metadata\n        if metadata:\n            message[\"metadata\"] = json.dumps(metadata)\n\n        # Publish to Redis stream\n        try:\n            stream_id = self.client.xadd(self.stream_name, message, maxlen=maxlen)\n            if self.verbose:\n                logger.info(f\"Published {width}x{height} image ({compressed_size} bytes)\")\n            return str(stream_id)\n        except RedisError as e:\n            logger.error(f\"Failed to publish image to Redis: {e}\")\n            raise RedisPublishError(f\"Failed to publish image: {e}\") from e\n\n    def get_latest_image(self) -&gt; Optional[Tuple[ImageArray, ImageMetadata]]:\n        \"\"\"\n        Ruft den neuesten Frame aus dem Stream ab.\n\n        Retrieve the newest frame from the stream.\n\n        Returns:\n            Optional[Tuple[ImageArray, ImageMetadata]]: Ein Tupel aus (image_array, metadata_dict), falls ein Frame vorhanden ist, andernfalls None. (A tuple of (image_array, metadata_dict) if a frame is present, otherwise None).\n\n        Raises:\n            RedisRetrievalError: Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).\n        \"\"\"\n        try:\n            messages = self.client.xrevrange(self.stream_name, count=1)\n            if not messages:\n                return None\n\n            msg_id, fields = messages[0]\n            return self._decode_variable_image(fields)\n\n        except RedisError as e:\n            logger.error(f\"Error getting latest image from Redis: {e}\")\n            raise RedisRetrievalError(f\"Failed to retrieve latest image: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Unexpected error getting latest image: {e}\")\n            return None\n\n    def subscribe_variable_images(\n        self,\n        callback: Callable[[ImageArray, ImageMetadata, Dict[str, Any]], None],\n        block_ms: int = 1000,\n        start_after: str = \"$\",\n    ) -&gt; None:\n        \"\"\"\n        H\u00f6rt kontinuierlich auf neue Frames und ruft f\u00fcr jeden Frame einen Callback auf.\n\n        Continuously listen for new frames and invoke callback for each one.\n\n        Args:\n            callback (Callable[[ImageArray, ImageMetadata, Dict[str, Any]], None]): Funktion, die (image, metadata, image_info) erh\u00e4lt. (Function receiving (image, metadata, image_info)).\n            block_ms (int): Zeit\u00fcberschreitung f\u00fcr das zugrunde liegende Redis xread. (Timeout for the underlying Redis xread).\n            start_after (str): Redis-Stream-ID, nach der mit dem Lesen begonnen werden soll. (Redis stream ID after which to start reading).\n\n        Raises:\n            RedisRetrievalError: Wenn das Abonnement fehlschl\u00e4gt. (If subscription fails).\n        \"\"\"\n        last_id = start_after\n        if self.verbose:\n            logger.info(f\"Subscribing to image stream {self.stream_name}...\")\n\n        try:\n            while True:\n                messages = self.client.xread({self.stream_name: last_id}, block=block_ms, count=1)\n\n                for stream, msgs in messages:\n                    for msg_id, fields in msgs:\n                        result = self._decode_variable_image(fields)\n                        if result:\n                            image, metadata = result\n\n                            # Prepare image info for callback\n                            image_info = {\n                                \"width\": image.shape[1],\n                                \"height\": image.shape[0],\n                                \"channels\": (image.shape[2] if len(image.shape) == 3 else 1),\n                                \"timestamp\": float(fields.get(\"timestamp\", \"0\")),\n                                \"compressed_size\": int(fields.get(\"compressed_size\", \"0\")),\n                                \"original_size\": int(fields.get(\"original_size\", \"0\")),\n                            }\n\n                            callback(image, metadata, image_info)\n                        last_id = msg_id\n\n        except KeyboardInterrupt:\n            logger.info(\"Stopped subscribing to images\")\n        except RedisError as e:\n            logger.error(f\"Redis error in image subscription: {e}\")\n            raise RedisRetrievalError(f\"Image subscription failed: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Unexpected error in image subscription: {e}\")\n            time.sleep(0.1)\n\n    def _decode_variable_image(self, fields: Dict[str, Any]) -&gt; Optional[Tuple[ImageArray, ImageMetadata]]:\n        \"\"\"\n        Dekodiert einen Redis-Stream-Eintrag, der ein Bild enth\u00e4lt.\n\n        Decode a Redis stream entry that contains an image.\n\n        Args:\n            fields (Dict[str, Any]): Schl\u00fcssel/Wert-Paare aus einem Redis-Eintrag. (Key/value pairs from a Redis entry).\n\n        Returns:\n            Optional[Tuple[ImageArray, ImageMetadata]]: Ein Tupel aus (image_array, metadata_dict) oder None, falls die Dekodierung fehlschl\u00e4gt. (A tuple of (image_array, metadata_dict) or None if decoding fails).\n        \"\"\"\n        try:\n            # Extract image parameters\n            width = int(fields[\"width\"])\n            height = int(fields[\"height\"])\n            channels = int(fields[\"channels\"])\n            format_type = fields[\"format\"]\n\n            # Decode image data\n            image_data = base64.b64decode(fields[\"image_data\"])\n\n            if format_type == \"jpeg\":\n                # Decode JPEG\n                nparr = np.frombuffer(image_data, np.uint8)\n                image = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\n                if image is None:\n                    raise RuntimeError(\"JPEG decoding returned None\")\n            else:\n                # Decode raw image with specified dimensions\n                dtype = fields[\"dtype\"]\n                shape: Tuple[int, ...]\n                if channels == 1:\n                    shape = (height, width)\n                else:\n                    shape = (height, width, channels)\n                image = np.frombuffer(image_data, dtype=dtype).reshape(shape)\n\n            # Extract metadata if available\n            metadata = {}\n            if \"metadata\" in fields:\n                metadata = json.loads(fields[\"metadata\"])\n\n            return image, metadata\n\n        except Exception as e:\n            if self.verbose:\n                logger.error(f\"Error decoding variable image: {e}\")\n            return None\n\n    def get_stream_stats(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Ruft Buchhaltungsinformationen \u00fcber den Redis-Stream ab.\n\n        Retrieve bookkeeping information about the Redis stream.\n\n        Returns:\n            Dict[str, Any]: Dictionary mit Stream-Statistiken. (Dictionary with stream statistics).\n        \"\"\"\n        try:\n            info = self.client.xinfo_stream(self.stream_name)\n            return {\n                \"total_messages\": info.get(\"length\", 0),\n                \"first_entry_id\": info.get(\"first-entry\", [None])[0],\n                \"last_entry_id\": info.get(\"last-entry\", [None])[0],\n            }\n        except Exception as e:\n            return {\"error\": f\"Stream not found or empty: {e}\"}\n</code></pre>"},{"location":"api/streamer/#redis_robot_comm.redis_image_streamer.RedisImageStreamer-functions","title":"Functions","text":""},{"location":"api/streamer/#redis_robot_comm.redis_image_streamer.RedisImageStreamer.__init__","title":"<code>__init__(host=None, port=None, stream_name='robot_camera', config=None)</code>","text":"<p>Initialisiert den Redis Image Streamer.</p> <p>Initialize the Redis image streamer.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>Optional[str]</code> <p>Hostname oder IP-Adresse des Redis-Servers. (Redis server hostname or IP address).</p> <code>None</code> <code>port</code> <code>Optional[int]</code> <p>Port des Redis-Servers. (Redis server port).</p> <code>None</code> <code>stream_name</code> <code>str</code> <p>Name des Streams, der die Bild-Frames enthalten wird. (Name of the stream that will hold the image frames).</p> <code>'robot_camera'</code> <code>config</code> <code>Optional[RedisConfig]</code> <p>Optionale RedisConfig-Instanz. (Optional RedisConfig instance).</p> <code>None</code> <p>Raises:</p> Type Description <code>RedisConnectionError</code> <p>Wenn die Verbindung zu Redis fehlschl\u00e4gt. (If connection to Redis fails).</p> Source code in <code>redis_robot_comm/redis_image_streamer.py</code> <pre><code>def __init__(\n    self,\n    host: Optional[str] = None,\n    port: Optional[int] = None,\n    stream_name: str = \"robot_camera\",\n    config: Optional[RedisConfig] = None,\n) -&gt; None:\n    \"\"\"\n    Initialisiert den Redis Image Streamer.\n\n    Initialize the Redis image streamer.\n\n    Args:\n        host (Optional[str]): Hostname oder IP-Adresse des Redis-Servers. (Redis server hostname or IP address).\n        port (Optional[int]): Port des Redis-Servers. (Redis server port).\n        stream_name (str): Name des Streams, der die Bild-Frames enthalten wird. (Name of the stream that will hold the image frames).\n        config (Optional[RedisConfig]): Optionale RedisConfig-Instanz. (Optional RedisConfig instance).\n\n    Raises:\n        RedisConnectionError: Wenn die Verbindung zu Redis fehlschl\u00e4gt. (If connection to Redis fails).\n    \"\"\"\n    if config is None:\n        config = get_redis_config()\n\n    # Override config with explicit parameters if provided\n    host = host or config.host\n    port = port or config.port\n\n    validate_stream_name(stream_name)\n    self.stream_name: str = stream_name\n    self.verbose: bool = False\n    try:\n        self.client = redis.Redis(\n            host=host,\n            port=port,\n            db=config.db,\n            password=config.password,\n            socket_timeout=config.socket_timeout,\n            socket_connect_timeout=config.socket_connect_timeout,\n            retry_on_timeout=config.retry_on_timeout,\n            max_connections=config.max_connections,\n            decode_responses=True,\n        )\n        self.client.ping()\n    except RedisError as e:\n        raise RedisConnectionError(f\"Failed to connect to Redis: {e}\") from e\n</code></pre>"},{"location":"api/streamer/#redis_robot_comm.redis_image_streamer.RedisImageStreamer.get_latest_image","title":"<code>get_latest_image()</code>","text":"<p>Ruft den neuesten Frame aus dem Stream ab.</p> <p>Retrieve the newest frame from the stream.</p> <p>Returns:</p> Type Description <code>Optional[Tuple[ImageArray, ImageMetadata]]</code> <p>Optional[Tuple[ImageArray, ImageMetadata]]: Ein Tupel aus (image_array, metadata_dict), falls ein Frame vorhanden ist, andernfalls None. (A tuple of (image_array, metadata_dict) if a frame is present, otherwise None).</p> <p>Raises:</p> Type Description <code>RedisRetrievalError</code> <p>Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).</p> Source code in <code>redis_robot_comm/redis_image_streamer.py</code> <pre><code>def get_latest_image(self) -&gt; Optional[Tuple[ImageArray, ImageMetadata]]:\n    \"\"\"\n    Ruft den neuesten Frame aus dem Stream ab.\n\n    Retrieve the newest frame from the stream.\n\n    Returns:\n        Optional[Tuple[ImageArray, ImageMetadata]]: Ein Tupel aus (image_array, metadata_dict), falls ein Frame vorhanden ist, andernfalls None. (A tuple of (image_array, metadata_dict) if a frame is present, otherwise None).\n\n    Raises:\n        RedisRetrievalError: Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).\n    \"\"\"\n    try:\n        messages = self.client.xrevrange(self.stream_name, count=1)\n        if not messages:\n            return None\n\n        msg_id, fields = messages[0]\n        return self._decode_variable_image(fields)\n\n    except RedisError as e:\n        logger.error(f\"Error getting latest image from Redis: {e}\")\n        raise RedisRetrievalError(f\"Failed to retrieve latest image: {e}\") from e\n    except Exception as e:\n        logger.error(f\"Unexpected error getting latest image: {e}\")\n        return None\n</code></pre>"},{"location":"api/streamer/#redis_robot_comm.redis_image_streamer.RedisImageStreamer.get_stream_stats","title":"<code>get_stream_stats()</code>","text":"<p>Ruft Buchhaltungsinformationen \u00fcber den Redis-Stream ab.</p> <p>Retrieve bookkeeping information about the Redis stream.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary mit Stream-Statistiken. (Dictionary with stream statistics).</p> Source code in <code>redis_robot_comm/redis_image_streamer.py</code> <pre><code>def get_stream_stats(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Ruft Buchhaltungsinformationen \u00fcber den Redis-Stream ab.\n\n    Retrieve bookkeeping information about the Redis stream.\n\n    Returns:\n        Dict[str, Any]: Dictionary mit Stream-Statistiken. (Dictionary with stream statistics).\n    \"\"\"\n    try:\n        info = self.client.xinfo_stream(self.stream_name)\n        return {\n            \"total_messages\": info.get(\"length\", 0),\n            \"first_entry_id\": info.get(\"first-entry\", [None])[0],\n            \"last_entry_id\": info.get(\"last-entry\", [None])[0],\n        }\n    except Exception as e:\n        return {\"error\": f\"Stream not found or empty: {e}\"}\n</code></pre>"},{"location":"api/streamer/#redis_robot_comm.redis_image_streamer.RedisImageStreamer.publish_image","title":"<code>publish_image(image, metadata=None, compress_jpeg=True, quality=80, maxlen=5)</code>","text":"<p>Ver\u00f6ffentlicht einen einzelnen Bild-Frame im Redis-Stream.</p> <p>Publish a single image frame to the Redis stream.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ImageArray</code> <p>OpenCV-Bild-Array (HxWxC oder HxW f\u00fcr Graustufen). (OpenCV image array (H\u00d7W\u00d7C or H\u00d7W for grayscale)).</p> required <code>metadata</code> <code>Optional[ImageMetadata]</code> <p>Beliebige Metadaten, die zusammen mit dem Frame gespeichert werden. (Arbitrary metadata stored alongside the frame).</p> <code>None</code> <code>compress_jpeg</code> <code>bool</code> <p>Gibt an, ob das Bild in das JPEG-Format komprimiert werden soll. (Whether to compress the image to JPEG).</p> <code>True</code> <code>quality</code> <code>int</code> <p>JPEG-Kompressionsqualit\u00e4t (1-100). (JPEG compression quality (1-100)).</p> <code>80</code> <code>maxlen</code> <code>int</code> <p>Maximale Anzahl von Eintr\u00e4gen, die im Stream gehalten werden sollen. (Maximum number of entries to keep in the stream).</p> <code>5</code> <p>Returns:</p> Name Type Description <code>StreamID</code> <code>StreamID</code> <p>Die eindeutige Redis-Eintrags-ID. (The unique Redis entry ID).</p> <p>Raises:</p> Type Description <code>InvalidImageError</code> <p>Wenn das bereitgestellte Bild ung\u00fcltig ist. (If the supplied image is invalid).</p> <code>RedisPublishError</code> <p>Wenn die Ver\u00f6ffentlichung bei Redis fehlschl\u00e4gt. (If publishing to Redis fails).</p> Source code in <code>redis_robot_comm/redis_image_streamer.py</code> <pre><code>@retry_on_connection_error(max_attempts=3, delay=0.5)\ndef publish_image(\n    self,\n    image: ImageArray,\n    metadata: Optional[ImageMetadata] = None,\n    compress_jpeg: bool = True,\n    quality: int = 80,\n    maxlen: int = 5,\n) -&gt; StreamID:\n    \"\"\"\n    Ver\u00f6ffentlicht einen einzelnen Bild-Frame im Redis-Stream.\n\n    Publish a single image frame to the Redis stream.\n\n    Args:\n        image (ImageArray): OpenCV-Bild-Array (HxWxC oder HxW f\u00fcr Graustufen). (OpenCV image array (H\u00d7W\u00d7C or H\u00d7W for grayscale)).\n        metadata (Optional[ImageMetadata]): Beliebige Metadaten, die zusammen mit dem Frame gespeichert werden. (Arbitrary metadata stored alongside the frame).\n        compress_jpeg (bool): Gibt an, ob das Bild in das JPEG-Format komprimiert werden soll. (Whether to compress the image to JPEG).\n        quality (int): JPEG-Kompressionsqualit\u00e4t (1-100). (JPEG compression quality (1-100)).\n        maxlen (int): Maximale Anzahl von Eintr\u00e4gen, die im Stream gehalten werden sollen. (Maximum number of entries to keep in the stream).\n\n    Returns:\n        StreamID: Die eindeutige Redis-Eintrags-ID. (The unique Redis entry ID).\n\n    Raises:\n        InvalidImageError: Wenn das bereitgestellte Bild ung\u00fcltig ist. (If the supplied image is invalid).\n        RedisPublishError: Wenn die Ver\u00f6ffentlichung bei Redis fehlschl\u00e4gt. (If publishing to Redis fails).\n    \"\"\"\n    try:\n        validate_image(image)\n    except InvalidImageError as e:\n        logger.error(f\"Image validation failed: {e}\")\n        raise\n\n    timestamp = time.time()\n\n    # Handle different image sizes dynamically\n    height, width = image.shape[:2]\n    channels = image.shape[2] if len(image.shape) == 3 else 1\n\n    if compress_jpeg:\n        # Compress to JPEG\n        success, buffer = cv2.imencode(\".jpg\", image, [cv2.IMWRITE_JPEG_QUALITY, quality])\n        if not success:\n            raise InvalidImageError(\"Failed to compress image to JPEG\")\n        image_data = base64.b64encode(buffer).decode(\"utf-8\")\n        format_type = \"jpeg\"\n        compressed_size = len(buffer)\n    else:\n        # Raw image data\n        image_data = base64.b64encode(image.tobytes()).decode(\"utf-8\")\n        format_type = \"raw\"\n        compressed_size = image.nbytes\n\n    # Prepare message with dynamic image info\n    message = {\n        \"timestamp\": str(timestamp),\n        \"image_data\": image_data,\n        \"format\": format_type,\n        \"width\": str(width),\n        \"height\": str(height),\n        \"channels\": str(channels),\n        \"dtype\": str(image.dtype),\n        \"compressed_size\": str(compressed_size),\n        \"original_size\": str(image.nbytes),\n    }\n\n    # Add optional metadata\n    if metadata:\n        message[\"metadata\"] = json.dumps(metadata)\n\n    # Publish to Redis stream\n    try:\n        stream_id = self.client.xadd(self.stream_name, message, maxlen=maxlen)\n        if self.verbose:\n            logger.info(f\"Published {width}x{height} image ({compressed_size} bytes)\")\n        return str(stream_id)\n    except RedisError as e:\n        logger.error(f\"Failed to publish image to Redis: {e}\")\n        raise RedisPublishError(f\"Failed to publish image: {e}\") from e\n</code></pre>"},{"location":"api/streamer/#redis_robot_comm.redis_image_streamer.RedisImageStreamer.subscribe_variable_images","title":"<code>subscribe_variable_images(callback, block_ms=1000, start_after='$')</code>","text":"<p>H\u00f6rt kontinuierlich auf neue Frames und ruft f\u00fcr jeden Frame einen Callback auf.</p> <p>Continuously listen for new frames and invoke callback for each one.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ImageArray, ImageMetadata, Dict[str, Any]], None]</code> <p>Funktion, die (image, metadata, image_info) erh\u00e4lt. (Function receiving (image, metadata, image_info)).</p> required <code>block_ms</code> <code>int</code> <p>Zeit\u00fcberschreitung f\u00fcr das zugrunde liegende Redis xread. (Timeout for the underlying Redis xread).</p> <code>1000</code> <code>start_after</code> <code>str</code> <p>Redis-Stream-ID, nach der mit dem Lesen begonnen werden soll. (Redis stream ID after which to start reading).</p> <code>'$'</code> <p>Raises:</p> Type Description <code>RedisRetrievalError</code> <p>Wenn das Abonnement fehlschl\u00e4gt. (If subscription fails).</p> Source code in <code>redis_robot_comm/redis_image_streamer.py</code> <pre><code>def subscribe_variable_images(\n    self,\n    callback: Callable[[ImageArray, ImageMetadata, Dict[str, Any]], None],\n    block_ms: int = 1000,\n    start_after: str = \"$\",\n) -&gt; None:\n    \"\"\"\n    H\u00f6rt kontinuierlich auf neue Frames und ruft f\u00fcr jeden Frame einen Callback auf.\n\n    Continuously listen for new frames and invoke callback for each one.\n\n    Args:\n        callback (Callable[[ImageArray, ImageMetadata, Dict[str, Any]], None]): Funktion, die (image, metadata, image_info) erh\u00e4lt. (Function receiving (image, metadata, image_info)).\n        block_ms (int): Zeit\u00fcberschreitung f\u00fcr das zugrunde liegende Redis xread. (Timeout for the underlying Redis xread).\n        start_after (str): Redis-Stream-ID, nach der mit dem Lesen begonnen werden soll. (Redis stream ID after which to start reading).\n\n    Raises:\n        RedisRetrievalError: Wenn das Abonnement fehlschl\u00e4gt. (If subscription fails).\n    \"\"\"\n    last_id = start_after\n    if self.verbose:\n        logger.info(f\"Subscribing to image stream {self.stream_name}...\")\n\n    try:\n        while True:\n            messages = self.client.xread({self.stream_name: last_id}, block=block_ms, count=1)\n\n            for stream, msgs in messages:\n                for msg_id, fields in msgs:\n                    result = self._decode_variable_image(fields)\n                    if result:\n                        image, metadata = result\n\n                        # Prepare image info for callback\n                        image_info = {\n                            \"width\": image.shape[1],\n                            \"height\": image.shape[0],\n                            \"channels\": (image.shape[2] if len(image.shape) == 3 else 1),\n                            \"timestamp\": float(fields.get(\"timestamp\", \"0\")),\n                            \"compressed_size\": int(fields.get(\"compressed_size\", \"0\")),\n                            \"original_size\": int(fields.get(\"original_size\", \"0\")),\n                        }\n\n                        callback(image, metadata, image_info)\n                    last_id = msg_id\n\n    except KeyboardInterrupt:\n        logger.info(\"Stopped subscribing to images\")\n    except RedisError as e:\n        logger.error(f\"Redis error in image subscription: {e}\")\n        raise RedisRetrievalError(f\"Image subscription failed: {e}\") from e\n    except Exception as e:\n        logger.error(f\"Unexpected error in image subscription: {e}\")\n        time.sleep(0.1)\n</code></pre>"},{"location":"api/text_overlay/","title":"RedisTextOverlayManager","text":""},{"location":"api/text_overlay/#redis_robot_comm.redis_text_overlay.RedisTextOverlayManager","title":"<code>redis_robot_comm.redis_text_overlay.RedisTextOverlayManager</code>","text":"<p>Verwaltet Text-Overlays f\u00fcr Roboter-Videoaufnahmen \u00fcber Redis-Streams.</p> <p>Manages text overlays for robot video recordings via Redis streams.</p> <p>Publisher (MCP-Server): Ver\u00f6ffentlichen Benutzeraufgaben und Robotersprache. (Publish user tasks and robot speech). Consumer (Aufzeichnungsskript): Abonnieren, um Texte im Video anzuzeigen. (Subscribe to display texts in video).</p> Source code in <code>redis_robot_comm/redis_text_overlay.py</code> <pre><code>class RedisTextOverlayManager:\n    \"\"\"\n    Verwaltet Text-Overlays f\u00fcr Roboter-Videoaufnahmen \u00fcber Redis-Streams.\n\n    Manages text overlays for robot video recordings via Redis streams.\n\n    Publisher (MCP-Server): Ver\u00f6ffentlichen Benutzeraufgaben und Robotersprache. (Publish user tasks and robot speech).\n    Consumer (Aufzeichnungsskript): Abonnieren, um Texte im Video anzuzeigen. (Subscribe to display texts in video).\n    \"\"\"\n\n    def __init__(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        stream_name: str = \"video_text_overlays\",\n        config: Optional[RedisConfig] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialisiert den Text-Overlay-Manager.\n\n        Initialize the text overlay manager.\n\n        Args:\n            host (Optional[str]): Redis-Server-Host. (Redis server host).\n            port (Optional[int]): Redis-Server-Port. (Redis server port).\n            stream_name (str): Name des Redis-Streams f\u00fcr Text-Overlays. (Name of the Redis stream for text overlays).\n            config (Optional[RedisConfig]): Optionale RedisConfig-Instanz. (Optional RedisConfig instance).\n\n        Raises:\n            RedisConnectionError: Wenn die Verbindung zu Redis fehlschl\u00e4gt. (If connection to Redis fails).\n        \"\"\"\n        if config is None:\n            config = get_redis_config()\n\n        # Override config with explicit parameters if provided\n        host = host or config.host\n        port = port or config.port\n\n        validate_stream_name(stream_name)\n        self.stream_name: str = stream_name\n        self.verbose: bool = False\n        try:\n            self.client = redis.Redis(\n                host=host,\n                port=port,\n                db=config.db,\n                password=config.password,\n                socket_timeout=config.socket_timeout,\n                socket_connect_timeout=config.socket_connect_timeout,\n                retry_on_timeout=config.retry_on_timeout,\n                max_connections=config.max_connections,\n                decode_responses=True,\n            )\n            self.client.ping()\n        except RedisError as e:\n            raise RedisConnectionError(f\"Failed to connect to Redis: {e}\") from e\n\n    def publish_user_task(self, task: str, metadata: Optional[Dict[str, Any]] = None) -&gt; Optional[StreamID]:\n        \"\"\"\n        Ver\u00f6ffentlicht eine Benutzeraufgabe/einen Benutzerbefehl.\n\n        Publish a user task/command.\n\n        Args:\n            task (str): Die Aufgabe/der Befehl des Benutzers in nat\u00fcrlicher Sprache. (The user's natural language task/command).\n            metadata (Optional[Dict[str, Any]]): Optionale Metadaten (z. B. user_id, session_id). (Optional metadata (e.g., user_id, session_id)).\n\n        Returns:\n            Optional[StreamID]: Redis-Stream-Eintrags-ID oder None, falls die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).\n        \"\"\"\n        return self._publish_text(text=task, text_type=TextType.USER_TASK, metadata=metadata)\n\n    def publish_robot_speech(\n        self,\n        speech: str,\n        duration_seconds: float = 4.0,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -&gt; Optional[StreamID]:\n        \"\"\"\n        Ver\u00f6ffentlicht eine Roboteraussage/-erkl\u00e4rung.\n\n        Publish robot speech/explanation.\n\n        Args:\n            speech (str): Was der Roboter sagt. (What the robot is saying).\n            duration_seconds (float): Wie lange der Text angezeigt werden soll. (How long to display the text).\n            metadata (Optional[Dict[str, Any]]): Optionale Metadaten (z. B. tool_name, Priorit\u00e4t). (Optional metadata (e.g., tool_name, priority)).\n\n        Returns:\n            Optional[StreamID]: Redis-Stream-Eintrags-ID oder None, falls die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).\n        \"\"\"\n        if metadata is None:\n            metadata = {}\n\n        metadata[\"duration_seconds\"] = duration_seconds\n\n        return self._publish_text(text=speech, text_type=TextType.ROBOT_SPEECH, metadata=metadata)\n\n    def publish_system_message(\n        self,\n        message: str,\n        duration_seconds: float = 3.0,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -&gt; Optional[StreamID]:\n        \"\"\"\n        Ver\u00f6ffentlicht eine Systemnachricht (z. B. \"Aufzeichnung gestartet\").\n\n        Publish system message (e.g., \"Recording started\").\n\n        Args:\n            message (str): Text der Systemnachricht. (System message text).\n            duration_seconds (float): Wie lange die Nachricht angezeigt werden soll. (How long to display).\n            metadata (Optional[Dict[str, Any]]): Optionale Metadaten. (Optional metadata).\n\n        Returns:\n            Optional[StreamID]: Redis-Stream-Eintrags-ID oder None, falls die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).\n        \"\"\"\n        if metadata is None:\n            metadata = {}\n\n        metadata[\"duration_seconds\"] = duration_seconds\n\n        return self._publish_text(text=message, text_type=TextType.SYSTEM_MESSAGE, metadata=metadata)\n\n    @retry_on_connection_error(max_attempts=3, delay=0.5)\n    def _publish_text(\n        self,\n        text: str,\n        text_type: TextType,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -&gt; Optional[StreamID]:\n        \"\"\"\n        Interne Methode zum Ver\u00f6ffentlichen von Text-Overlays.\n\n        Internal method to publish text overlay.\n\n        Args:\n            text (str): Textinhalt. (Text content).\n            text_type (TextType): Typ des Textes (user_task, robot_speech, system_message). (Type of text (user_task, robot_speech, system_message)).\n            metadata (Optional[Dict[str, Any]]): Optionale Metadaten. (Optional metadata).\n\n        Returns:\n            Optional[StreamID]: Redis-Stream-Eintrags-ID oder None, falls die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).\n\n        Raises:\n            RedisPublishError: Wenn die Ver\u00f6ffentlichung bei Redis fehlschl\u00e4gt. (If publishing to Redis fails).\n        \"\"\"\n        message = {\n            \"timestamp\": str(time.time()),\n            \"text\": text,\n            \"type\": text_type.value,\n            \"metadata\": json.dumps(metadata or {}),\n        }\n\n        try:\n            # Keep last 100 entries\n            stream_id = self.client.xadd(self.stream_name, message, maxlen=100)\n\n            if self.verbose:\n                logger.info(f\"Published {text_type.value}: {text[:50]}...\")\n\n            return cast(Optional[StreamID], stream_id)\n\n        except RedisError as e:\n            logger.error(f\"Error publishing text overlay: {e}\")\n            raise RedisPublishError(f\"Failed to publish text overlay: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Unexpected error publishing text overlay: {e}\")\n            return None\n\n    def get_latest_texts(\n        self,\n        max_age_seconds: float = 10.0,\n        text_type: Optional[TextType] = None,\n    ) -&gt; List[TextOverlayDict]:\n        \"\"\"\n        Ruft aktuelle Text-Overlays ab.\n\n        Get recent text overlays.\n\n        Args:\n            max_age_seconds (float): Maximales Alter der abzurufenden Texte. (Maximum age of texts to retrieve).\n            text_type (Optional[TextType]): Filtern nach Texttyp (None = alle Typen). (Filter by text type (None = all types)).\n\n        Returns:\n            List[TextOverlayDict]: Liste von Text-Overlay-Dictionaries. (List of text overlay dictionaries).\n\n        Raises:\n            RedisRetrievalError: Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).\n        \"\"\"\n        try:\n            # Get recent messages\n            current_time = time.time()\n            start_id = f\"{int((current_time - max_age_seconds) * 1000)}-0\"\n\n            messages = self.client.xrange(self.stream_name, min=start_id, max=\"+\")\n\n            texts = []\n            for msg_id, fields in messages:\n                try:\n                    text_data = {\n                        \"id\": msg_id,\n                        \"timestamp\": float(fields.get(\"timestamp\", \"0\")),\n                        \"text\": fields.get(\"text\", \"\"),\n                        \"type\": fields.get(\"type\", \"\"),\n                        \"metadata\": json.loads(fields.get(\"metadata\", \"{}\")),\n                    }\n\n                    # Filter by type if specified\n                    if text_type is None or text_data[\"type\"] == text_type.value:\n                        texts.append(text_data)\n\n                except Exception as e:\n                    logger.error(f\"Error parsing text overlay: {e}\")\n                    continue\n\n            return cast(List[TextOverlayDict], texts)\n\n        except RedisError as e:\n            logger.error(f\"Error getting latest texts from Redis: {e}\")\n            raise RedisRetrievalError(f\"Failed to retrieve latest texts: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Unexpected error getting latest texts: {e}\")\n            return []\n\n    def get_current_user_task(self, max_age_seconds: float = 300.0) -&gt; Optional[str]:\n        \"\"\"\n        Ruft die aktuellste Benutzeraufgabe ab (falls noch relevant).\n\n        Get the most recent user task (if still relevant).\n\n        Args:\n            max_age_seconds (float): Maximales Alter, um als aktuell zu gelten (Standard: 5 Minuten). (Maximum age to consider current (default: 5 minutes)).\n\n        Returns:\n            Optional[str]: Aktuelle Benutzeraufgabe oder None. (Current user task or None).\n\n        Raises:\n            RedisRetrievalError: Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).\n        \"\"\"\n        try:\n            messages = self.client.xrevrange(self.stream_name, count=50)\n\n            current_time = time.time()\n\n            for msg_id, fields in messages:\n                msg_type = fields.get(\"type\", \"\")\n\n                if msg_type == TextType.USER_TASK.value:\n                    msg_timestamp = float(fields.get(\"timestamp\", \"0\"))\n\n                    # Check if still relevant\n                    if current_time - msg_timestamp &lt;= max_age_seconds:\n                        return str(fields.get(\"text\", \"\"))\n                    else:\n                        # Too old\n                        return None\n\n            return None\n\n        except RedisError as e:\n            logger.error(f\"Error getting current user task from Redis: {e}\")\n            raise RedisRetrievalError(f\"Failed to retrieve user task: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Unexpected error getting current user task: {e}\")\n            return None\n\n    def subscribe_to_texts(\n        self,\n        callback: Callable[[TextOverlayDict], None],\n        block_ms: int = 1000,\n        text_type: Optional[TextType] = None,\n    ) -&gt; None:\n        \"\"\"\n        Abonniert Text-Overlays und ruft f\u00fcr jedes einen Callback auf.\n\n        Subscribe to text overlays and call callback for each one.\n\n        Args:\n            callback (Callable[[TextOverlayDict], None]): Funktion, die ein Textdaten-Dictionary erh\u00e4lt. (Function receiving text data dictionary).\n            block_ms (int): Blockier-Timeout in Millisekunden. (Blocking timeout in milliseconds).\n            text_type (Optional[TextType]): Filtern nach Texttyp (None = alle Typen). (Filter by text type (None = all types)).\n\n        Raises:\n            RedisRetrievalError: Wenn das Abonnement fehlschl\u00e4gt. (If subscription fails).\n        \"\"\"\n        last_id = \"$\"  # Start from newest\n\n        if self.verbose:\n            logger.info(f\"Subscribing to text overlays on {self.stream_name} (type: {text_type or 'all'})...\")\n\n        try:\n            while True:\n                messages = self.client.xread({self.stream_name: last_id}, block=block_ms, count=1)\n\n                for stream, msgs in messages:\n                    for msg_id, fields in msgs:\n                        try:\n                            text_data = {\n                                \"id\": msg_id,\n                                \"timestamp\": float(fields.get(\"timestamp\", \"0\")),\n                                \"text\": fields.get(\"text\", \"\"),\n                                \"type\": fields.get(\"type\", \"\"),\n                                \"metadata\": json.loads(fields.get(\"metadata\", \"{}\")),\n                            }\n\n                            # Filter by type if specified\n                            if text_type is None or text_data[\"type\"] == text_type.value:\n                                callback(text_data)\n\n                            last_id = msg_id\n\n                        except Exception as e:\n                            logger.error(f\"Error processing text overlay: {e}\")\n\n        except KeyboardInterrupt:\n            logger.info(\"Stopped subscribing to text overlays\")\n        except RedisError as e:\n            logger.error(f\"Redis error in text overlay subscription: {e}\")\n            raise RedisRetrievalError(f\"Text overlay subscription failed: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Unexpected error in text overlay subscription: {e}\")\n\n    def clear_stream(self) -&gt; bool:\n        \"\"\"\n        L\u00f6scht den Text-Overlay-Stream.\n\n        Clear the text overlay stream.\n\n        Returns:\n            bool: True bei Erfolg, False andernfalls. (True if successful, False otherwise).\n        \"\"\"\n        try:\n            result = self.client.delete(self.stream_name)\n            if self.verbose:\n                logger.info(f\"Cleared text overlay stream: {result}\")\n            return bool(result)\n        except Exception as e:\n            logger.error(f\"Error clearing stream: {e}\")\n            return False\n\n    def get_stream_info(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Ruft Stream-Statistiken ab.\n\n        Get stream statistics.\n\n        Returns:\n            Dict[str, Any]: Stream-Informations-Dictionary. (Stream information dictionary).\n        \"\"\"\n        try:\n            info = self.client.xinfo_stream(self.stream_name)\n            return {\n                \"total_messages\": info.get(\"length\", 0),\n                \"first_entry_id\": info.get(\"first-entry\", [None])[0],\n                \"last_entry_id\": info.get(\"last-entry\", [None])[0],\n            }\n        except Exception as e:\n            return {\"error\": f\"Stream not found or empty: {e}\"}\n</code></pre>"},{"location":"api/text_overlay/#redis_robot_comm.redis_text_overlay.RedisTextOverlayManager-functions","title":"Functions","text":""},{"location":"api/text_overlay/#redis_robot_comm.redis_text_overlay.RedisTextOverlayManager.__init__","title":"<code>__init__(host=None, port=None, stream_name='video_text_overlays', config=None)</code>","text":"<p>Initialisiert den Text-Overlay-Manager.</p> <p>Initialize the text overlay manager.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>Optional[str]</code> <p>Redis-Server-Host. (Redis server host).</p> <code>None</code> <code>port</code> <code>Optional[int]</code> <p>Redis-Server-Port. (Redis server port).</p> <code>None</code> <code>stream_name</code> <code>str</code> <p>Name des Redis-Streams f\u00fcr Text-Overlays. (Name of the Redis stream for text overlays).</p> <code>'video_text_overlays'</code> <code>config</code> <code>Optional[RedisConfig]</code> <p>Optionale RedisConfig-Instanz. (Optional RedisConfig instance).</p> <code>None</code> <p>Raises:</p> Type Description <code>RedisConnectionError</code> <p>Wenn die Verbindung zu Redis fehlschl\u00e4gt. (If connection to Redis fails).</p> Source code in <code>redis_robot_comm/redis_text_overlay.py</code> <pre><code>def __init__(\n    self,\n    host: Optional[str] = None,\n    port: Optional[int] = None,\n    stream_name: str = \"video_text_overlays\",\n    config: Optional[RedisConfig] = None,\n) -&gt; None:\n    \"\"\"\n    Initialisiert den Text-Overlay-Manager.\n\n    Initialize the text overlay manager.\n\n    Args:\n        host (Optional[str]): Redis-Server-Host. (Redis server host).\n        port (Optional[int]): Redis-Server-Port. (Redis server port).\n        stream_name (str): Name des Redis-Streams f\u00fcr Text-Overlays. (Name of the Redis stream for text overlays).\n        config (Optional[RedisConfig]): Optionale RedisConfig-Instanz. (Optional RedisConfig instance).\n\n    Raises:\n        RedisConnectionError: Wenn die Verbindung zu Redis fehlschl\u00e4gt. (If connection to Redis fails).\n    \"\"\"\n    if config is None:\n        config = get_redis_config()\n\n    # Override config with explicit parameters if provided\n    host = host or config.host\n    port = port or config.port\n\n    validate_stream_name(stream_name)\n    self.stream_name: str = stream_name\n    self.verbose: bool = False\n    try:\n        self.client = redis.Redis(\n            host=host,\n            port=port,\n            db=config.db,\n            password=config.password,\n            socket_timeout=config.socket_timeout,\n            socket_connect_timeout=config.socket_connect_timeout,\n            retry_on_timeout=config.retry_on_timeout,\n            max_connections=config.max_connections,\n            decode_responses=True,\n        )\n        self.client.ping()\n    except RedisError as e:\n        raise RedisConnectionError(f\"Failed to connect to Redis: {e}\") from e\n</code></pre>"},{"location":"api/text_overlay/#redis_robot_comm.redis_text_overlay.RedisTextOverlayManager.clear_stream","title":"<code>clear_stream()</code>","text":"<p>L\u00f6scht den Text-Overlay-Stream.</p> <p>Clear the text overlay stream.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True bei Erfolg, False andernfalls. (True if successful, False otherwise).</p> Source code in <code>redis_robot_comm/redis_text_overlay.py</code> <pre><code>def clear_stream(self) -&gt; bool:\n    \"\"\"\n    L\u00f6scht den Text-Overlay-Stream.\n\n    Clear the text overlay stream.\n\n    Returns:\n        bool: True bei Erfolg, False andernfalls. (True if successful, False otherwise).\n    \"\"\"\n    try:\n        result = self.client.delete(self.stream_name)\n        if self.verbose:\n            logger.info(f\"Cleared text overlay stream: {result}\")\n        return bool(result)\n    except Exception as e:\n        logger.error(f\"Error clearing stream: {e}\")\n        return False\n</code></pre>"},{"location":"api/text_overlay/#redis_robot_comm.redis_text_overlay.RedisTextOverlayManager.get_current_user_task","title":"<code>get_current_user_task(max_age_seconds=300.0)</code>","text":"<p>Ruft die aktuellste Benutzeraufgabe ab (falls noch relevant).</p> <p>Get the most recent user task (if still relevant).</p> <p>Parameters:</p> Name Type Description Default <code>max_age_seconds</code> <code>float</code> <p>Maximales Alter, um als aktuell zu gelten (Standard: 5 Minuten). (Maximum age to consider current (default: 5 minutes)).</p> <code>300.0</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Aktuelle Benutzeraufgabe oder None. (Current user task or None).</p> <p>Raises:</p> Type Description <code>RedisRetrievalError</code> <p>Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).</p> Source code in <code>redis_robot_comm/redis_text_overlay.py</code> <pre><code>def get_current_user_task(self, max_age_seconds: float = 300.0) -&gt; Optional[str]:\n    \"\"\"\n    Ruft die aktuellste Benutzeraufgabe ab (falls noch relevant).\n\n    Get the most recent user task (if still relevant).\n\n    Args:\n        max_age_seconds (float): Maximales Alter, um als aktuell zu gelten (Standard: 5 Minuten). (Maximum age to consider current (default: 5 minutes)).\n\n    Returns:\n        Optional[str]: Aktuelle Benutzeraufgabe oder None. (Current user task or None).\n\n    Raises:\n        RedisRetrievalError: Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).\n    \"\"\"\n    try:\n        messages = self.client.xrevrange(self.stream_name, count=50)\n\n        current_time = time.time()\n\n        for msg_id, fields in messages:\n            msg_type = fields.get(\"type\", \"\")\n\n            if msg_type == TextType.USER_TASK.value:\n                msg_timestamp = float(fields.get(\"timestamp\", \"0\"))\n\n                # Check if still relevant\n                if current_time - msg_timestamp &lt;= max_age_seconds:\n                    return str(fields.get(\"text\", \"\"))\n                else:\n                    # Too old\n                    return None\n\n        return None\n\n    except RedisError as e:\n        logger.error(f\"Error getting current user task from Redis: {e}\")\n        raise RedisRetrievalError(f\"Failed to retrieve user task: {e}\") from e\n    except Exception as e:\n        logger.error(f\"Unexpected error getting current user task: {e}\")\n        return None\n</code></pre>"},{"location":"api/text_overlay/#redis_robot_comm.redis_text_overlay.RedisTextOverlayManager.get_latest_texts","title":"<code>get_latest_texts(max_age_seconds=10.0, text_type=None)</code>","text":"<p>Ruft aktuelle Text-Overlays ab.</p> <p>Get recent text overlays.</p> <p>Parameters:</p> Name Type Description Default <code>max_age_seconds</code> <code>float</code> <p>Maximales Alter der abzurufenden Texte. (Maximum age of texts to retrieve).</p> <code>10.0</code> <code>text_type</code> <code>Optional[TextType]</code> <p>Filtern nach Texttyp (None = alle Typen). (Filter by text type (None = all types)).</p> <code>None</code> <p>Returns:</p> Type Description <code>List[TextOverlayDict]</code> <p>List[TextOverlayDict]: Liste von Text-Overlay-Dictionaries. (List of text overlay dictionaries).</p> <p>Raises:</p> Type Description <code>RedisRetrievalError</code> <p>Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).</p> Source code in <code>redis_robot_comm/redis_text_overlay.py</code> <pre><code>def get_latest_texts(\n    self,\n    max_age_seconds: float = 10.0,\n    text_type: Optional[TextType] = None,\n) -&gt; List[TextOverlayDict]:\n    \"\"\"\n    Ruft aktuelle Text-Overlays ab.\n\n    Get recent text overlays.\n\n    Args:\n        max_age_seconds (float): Maximales Alter der abzurufenden Texte. (Maximum age of texts to retrieve).\n        text_type (Optional[TextType]): Filtern nach Texttyp (None = alle Typen). (Filter by text type (None = all types)).\n\n    Returns:\n        List[TextOverlayDict]: Liste von Text-Overlay-Dictionaries. (List of text overlay dictionaries).\n\n    Raises:\n        RedisRetrievalError: Wenn der Abruf von Redis fehlschl\u00e4gt. (If retrieval from Redis fails).\n    \"\"\"\n    try:\n        # Get recent messages\n        current_time = time.time()\n        start_id = f\"{int((current_time - max_age_seconds) * 1000)}-0\"\n\n        messages = self.client.xrange(self.stream_name, min=start_id, max=\"+\")\n\n        texts = []\n        for msg_id, fields in messages:\n            try:\n                text_data = {\n                    \"id\": msg_id,\n                    \"timestamp\": float(fields.get(\"timestamp\", \"0\")),\n                    \"text\": fields.get(\"text\", \"\"),\n                    \"type\": fields.get(\"type\", \"\"),\n                    \"metadata\": json.loads(fields.get(\"metadata\", \"{}\")),\n                }\n\n                # Filter by type if specified\n                if text_type is None or text_data[\"type\"] == text_type.value:\n                    texts.append(text_data)\n\n            except Exception as e:\n                logger.error(f\"Error parsing text overlay: {e}\")\n                continue\n\n        return cast(List[TextOverlayDict], texts)\n\n    except RedisError as e:\n        logger.error(f\"Error getting latest texts from Redis: {e}\")\n        raise RedisRetrievalError(f\"Failed to retrieve latest texts: {e}\") from e\n    except Exception as e:\n        logger.error(f\"Unexpected error getting latest texts: {e}\")\n        return []\n</code></pre>"},{"location":"api/text_overlay/#redis_robot_comm.redis_text_overlay.RedisTextOverlayManager.get_stream_info","title":"<code>get_stream_info()</code>","text":"<p>Ruft Stream-Statistiken ab.</p> <p>Get stream statistics.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Stream-Informations-Dictionary. (Stream information dictionary).</p> Source code in <code>redis_robot_comm/redis_text_overlay.py</code> <pre><code>def get_stream_info(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Ruft Stream-Statistiken ab.\n\n    Get stream statistics.\n\n    Returns:\n        Dict[str, Any]: Stream-Informations-Dictionary. (Stream information dictionary).\n    \"\"\"\n    try:\n        info = self.client.xinfo_stream(self.stream_name)\n        return {\n            \"total_messages\": info.get(\"length\", 0),\n            \"first_entry_id\": info.get(\"first-entry\", [None])[0],\n            \"last_entry_id\": info.get(\"last-entry\", [None])[0],\n        }\n    except Exception as e:\n        return {\"error\": f\"Stream not found or empty: {e}\"}\n</code></pre>"},{"location":"api/text_overlay/#redis_robot_comm.redis_text_overlay.RedisTextOverlayManager.publish_robot_speech","title":"<code>publish_robot_speech(speech, duration_seconds=4.0, metadata=None)</code>","text":"<p>Ver\u00f6ffentlicht eine Roboteraussage/-erkl\u00e4rung.</p> <p>Publish robot speech/explanation.</p> <p>Parameters:</p> Name Type Description Default <code>speech</code> <code>str</code> <p>Was der Roboter sagt. (What the robot is saying).</p> required <code>duration_seconds</code> <code>float</code> <p>Wie lange der Text angezeigt werden soll. (How long to display the text).</p> <code>4.0</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Optionale Metadaten (z. B. tool_name, Priorit\u00e4t). (Optional metadata (e.g., tool_name, priority)).</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[StreamID]</code> <p>Optional[StreamID]: Redis-Stream-Eintrags-ID oder None, falls die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).</p> Source code in <code>redis_robot_comm/redis_text_overlay.py</code> <pre><code>def publish_robot_speech(\n    self,\n    speech: str,\n    duration_seconds: float = 4.0,\n    metadata: Optional[Dict[str, Any]] = None,\n) -&gt; Optional[StreamID]:\n    \"\"\"\n    Ver\u00f6ffentlicht eine Roboteraussage/-erkl\u00e4rung.\n\n    Publish robot speech/explanation.\n\n    Args:\n        speech (str): Was der Roboter sagt. (What the robot is saying).\n        duration_seconds (float): Wie lange der Text angezeigt werden soll. (How long to display the text).\n        metadata (Optional[Dict[str, Any]]): Optionale Metadaten (z. B. tool_name, Priorit\u00e4t). (Optional metadata (e.g., tool_name, priority)).\n\n    Returns:\n        Optional[StreamID]: Redis-Stream-Eintrags-ID oder None, falls die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).\n    \"\"\"\n    if metadata is None:\n        metadata = {}\n\n    metadata[\"duration_seconds\"] = duration_seconds\n\n    return self._publish_text(text=speech, text_type=TextType.ROBOT_SPEECH, metadata=metadata)\n</code></pre>"},{"location":"api/text_overlay/#redis_robot_comm.redis_text_overlay.RedisTextOverlayManager.publish_system_message","title":"<code>publish_system_message(message, duration_seconds=3.0, metadata=None)</code>","text":"<p>Ver\u00f6ffentlicht eine Systemnachricht (z. B. \"Aufzeichnung gestartet\").</p> <p>Publish system message (e.g., \"Recording started\").</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Text der Systemnachricht. (System message text).</p> required <code>duration_seconds</code> <code>float</code> <p>Wie lange die Nachricht angezeigt werden soll. (How long to display).</p> <code>3.0</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Optionale Metadaten. (Optional metadata).</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[StreamID]</code> <p>Optional[StreamID]: Redis-Stream-Eintrags-ID oder None, falls die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).</p> Source code in <code>redis_robot_comm/redis_text_overlay.py</code> <pre><code>def publish_system_message(\n    self,\n    message: str,\n    duration_seconds: float = 3.0,\n    metadata: Optional[Dict[str, Any]] = None,\n) -&gt; Optional[StreamID]:\n    \"\"\"\n    Ver\u00f6ffentlicht eine Systemnachricht (z. B. \"Aufzeichnung gestartet\").\n\n    Publish system message (e.g., \"Recording started\").\n\n    Args:\n        message (str): Text der Systemnachricht. (System message text).\n        duration_seconds (float): Wie lange die Nachricht angezeigt werden soll. (How long to display).\n        metadata (Optional[Dict[str, Any]]): Optionale Metadaten. (Optional metadata).\n\n    Returns:\n        Optional[StreamID]: Redis-Stream-Eintrags-ID oder None, falls die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).\n    \"\"\"\n    if metadata is None:\n        metadata = {}\n\n    metadata[\"duration_seconds\"] = duration_seconds\n\n    return self._publish_text(text=message, text_type=TextType.SYSTEM_MESSAGE, metadata=metadata)\n</code></pre>"},{"location":"api/text_overlay/#redis_robot_comm.redis_text_overlay.RedisTextOverlayManager.publish_user_task","title":"<code>publish_user_task(task, metadata=None)</code>","text":"<p>Ver\u00f6ffentlicht eine Benutzeraufgabe/einen Benutzerbefehl.</p> <p>Publish a user task/command.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>Die Aufgabe/der Befehl des Benutzers in nat\u00fcrlicher Sprache. (The user's natural language task/command).</p> required <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Optionale Metadaten (z. B. user_id, session_id). (Optional metadata (e.g., user_id, session_id)).</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[StreamID]</code> <p>Optional[StreamID]: Redis-Stream-Eintrags-ID oder None, falls die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).</p> Source code in <code>redis_robot_comm/redis_text_overlay.py</code> <pre><code>def publish_user_task(self, task: str, metadata: Optional[Dict[str, Any]] = None) -&gt; Optional[StreamID]:\n    \"\"\"\n    Ver\u00f6ffentlicht eine Benutzeraufgabe/einen Benutzerbefehl.\n\n    Publish a user task/command.\n\n    Args:\n        task (str): Die Aufgabe/der Befehl des Benutzers in nat\u00fcrlicher Sprache. (The user's natural language task/command).\n        metadata (Optional[Dict[str, Any]]): Optionale Metadaten (z. B. user_id, session_id). (Optional metadata (e.g., user_id, session_id)).\n\n    Returns:\n        Optional[StreamID]: Redis-Stream-Eintrags-ID oder None, falls die Ver\u00f6ffentlichung fehlschl\u00e4gt. (Redis stream entry ID, or None if publishing fails).\n    \"\"\"\n    return self._publish_text(text=task, text_type=TextType.USER_TASK, metadata=metadata)\n</code></pre>"},{"location":"api/text_overlay/#redis_robot_comm.redis_text_overlay.RedisTextOverlayManager.subscribe_to_texts","title":"<code>subscribe_to_texts(callback, block_ms=1000, text_type=None)</code>","text":"<p>Abonniert Text-Overlays und ruft f\u00fcr jedes einen Callback auf.</p> <p>Subscribe to text overlays and call callback for each one.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TextOverlayDict], None]</code> <p>Funktion, die ein Textdaten-Dictionary erh\u00e4lt. (Function receiving text data dictionary).</p> required <code>block_ms</code> <code>int</code> <p>Blockier-Timeout in Millisekunden. (Blocking timeout in milliseconds).</p> <code>1000</code> <code>text_type</code> <code>Optional[TextType]</code> <p>Filtern nach Texttyp (None = alle Typen). (Filter by text type (None = all types)).</p> <code>None</code> <p>Raises:</p> Type Description <code>RedisRetrievalError</code> <p>Wenn das Abonnement fehlschl\u00e4gt. (If subscription fails).</p> Source code in <code>redis_robot_comm/redis_text_overlay.py</code> <pre><code>def subscribe_to_texts(\n    self,\n    callback: Callable[[TextOverlayDict], None],\n    block_ms: int = 1000,\n    text_type: Optional[TextType] = None,\n) -&gt; None:\n    \"\"\"\n    Abonniert Text-Overlays und ruft f\u00fcr jedes einen Callback auf.\n\n    Subscribe to text overlays and call callback for each one.\n\n    Args:\n        callback (Callable[[TextOverlayDict], None]): Funktion, die ein Textdaten-Dictionary erh\u00e4lt. (Function receiving text data dictionary).\n        block_ms (int): Blockier-Timeout in Millisekunden. (Blocking timeout in milliseconds).\n        text_type (Optional[TextType]): Filtern nach Texttyp (None = alle Typen). (Filter by text type (None = all types)).\n\n    Raises:\n        RedisRetrievalError: Wenn das Abonnement fehlschl\u00e4gt. (If subscription fails).\n    \"\"\"\n    last_id = \"$\"  # Start from newest\n\n    if self.verbose:\n        logger.info(f\"Subscribing to text overlays on {self.stream_name} (type: {text_type or 'all'})...\")\n\n    try:\n        while True:\n            messages = self.client.xread({self.stream_name: last_id}, block=block_ms, count=1)\n\n            for stream, msgs in messages:\n                for msg_id, fields in msgs:\n                    try:\n                        text_data = {\n                            \"id\": msg_id,\n                            \"timestamp\": float(fields.get(\"timestamp\", \"0\")),\n                            \"text\": fields.get(\"text\", \"\"),\n                            \"type\": fields.get(\"type\", \"\"),\n                            \"metadata\": json.loads(fields.get(\"metadata\", \"{}\")),\n                        }\n\n                        # Filter by type if specified\n                        if text_type is None or text_data[\"type\"] == text_type.value:\n                            callback(text_data)\n\n                        last_id = msg_id\n\n                    except Exception as e:\n                        logger.error(f\"Error processing text overlay: {e}\")\n\n    except KeyboardInterrupt:\n        logger.info(\"Stopped subscribing to text overlays\")\n    except RedisError as e:\n        logger.error(f\"Redis error in text overlay subscription: {e}\")\n        raise RedisRetrievalError(f\"Text overlay subscription failed: {e}\") from e\n    except Exception as e:\n        logger.error(f\"Unexpected error in text overlay subscription: {e}\")\n</code></pre>"},{"location":"architecture/","title":"Architektur-\u00dcbersicht","text":""},{"location":"architecture/#systemdesign","title":"Systemdesign","text":"<p>Das System basiert auf einer dezentralen Architektur, bei der Redis als zentraler Message Broker f\u00fcr alle Datenstr\u00f6me fungiert.</p>"},{"location":"architecture/#komponenten-diagramm","title":"Komponenten-Diagramm","text":"graph TD     subgraph Client-Anwendungen         VD[Vision Detection]         RC[Robot Control]         MCP[MCP Server]     end      subgraph redis_robot_comm         RMB[RedisMessageBroker]         RIS[RedisImageStreamer]         RLM[RedisLabelManager]         RTO[RedisTextOverlayManager]     end      subgraph Redis-Infrastruktur         RS[(Redis Streams)]     end      VD --&gt; RMB     VD --&gt; RIS     RC --&gt; RMB     RC --&gt; RIS     MCP --&gt; RTO      RMB &lt;--&gt; RS     RIS &lt;--&gt; RS     RLM &lt;--&gt; RS     RTO &lt;--&gt; RS"},{"location":"architecture/#kernkomponenten","title":"Kernkomponenten","text":""},{"location":"architecture/#redismessagebroker","title":"RedisMessageBroker","text":"<p>Zust\u00e4ndig f\u00fcr das Streaming von Objekterkennungsdaten im JSON-Format. Unterst\u00fctzt Kameraposen und Zeitstempel.</p>"},{"location":"architecture/#redisimagestreamer","title":"RedisImageStreamer","text":"<p>Erm\u00f6glicht das Streaming von OpenCV-Bildern mit optionaler JPEG-Kompression. Optimiert f\u00fcr niedrige Latenz.</p>"},{"location":"architecture/#redislabelmanager","title":"RedisLabelManager","text":"<p>Verwaltet dynamisch die Liste der erkennbaren Objekte zwischen verschiedenen Prozessen.</p>"},{"location":"architecture/#redistextoverlaymanager","title":"RedisTextOverlayManager","text":"<p>Synchronisiert Texteinblendungen f\u00fcr Videoaufzeichnungen, unterteilt in Benutzeraufgaben, Robotersprache und Systemnachrichten.</p>"},{"location":"architecture/data_flow/","title":"Datenfluss","text":"<p>Der Datenaustausch erfolgt asynchron \u00fcber Redis Streams. Dies erm\u00f6glicht eine Entkopplung von Produzenten (z. B. Kamera-Treiber, KI-Modelle) und Konsumenten (z. B. Robotersteuerung, Visualisierung).</p>"},{"location":"architecture/data_flow/#bild-streaming-sequenz","title":"Bild-Streaming-Sequenz","text":"sequenceDiagram     participant P as Publisher (z.B. Kamera)     participant R as Redis Stream     participant C as Consumer (z.B. GUI)      P-&gt;&gt;P: Erfasse Bild     P-&gt;&gt;P: Komprimiere zu JPEG     P-&gt;&gt;R: XADD robot_camera (image_data, metadata)     R--&gt;&gt;P: Stream ID      C-&gt;&gt;R: XREAD/XREVRANGE robot_camera     R--&gt;&gt;C: Bilddaten + Metadaten     C-&gt;&gt;C: Dekodiere JPEG     C-&gt;&gt;C: Zeige Bild an"},{"location":"architecture/data_flow/#objekterkennungs-workflow","title":"Objekterkennungs-Workflow","text":"flowchart LR     Img[Bildquelle] --&gt; Det[Detektor]     Det --&gt; |Objektliste| Broker[RedisMessageBroker]     Broker --&gt; |XADD| Stream[(Redis Stream)]     Stream --&gt; |XREAD| Control[Robotersteuerung]     Control --&gt; |Aktion| Robot[Roboter]"},{"location":"development/contributing/","title":"Beitragen","text":"<p>Wir freuen uns \u00fcber Beitr\u00e4ge zum Projekt!</p>"},{"location":"development/contributing/#entwicklungsprozess","title":"Entwicklungsprozess","text":"<ol> <li>Forken Sie das Repository.</li> <li>Erstellen Sie einen neuen Branch f\u00fcr Ihre \u00c4nderungen.</li> <li>Implementieren Sie Ihre \u00c4nderungen und f\u00fcgen Sie Tests hinzu.</li> <li>Stellen Sie sicher, dass alle Tests bestehen.</li> <li>Erstellen Sie einen Pull Request.</li> </ol>"},{"location":"development/contributing/#code-stil","title":"Code-Stil","text":"<p>Wir verwenden: - Black f\u00fcr die Formatierung. - Ruff f\u00fcr das Linting. - mypy f\u00fcr die Typpr\u00fcfung.</p> <p>F\u00fchren Sie <code>pre-commit install</code> aus, um diese Pr\u00fcfungen automatisch vor jedem Commit durchzuf\u00fchren.</p>"},{"location":"development/metrics/","title":"Metriken zur Dokumentationsqualit\u00e4t","text":"<p>In diesem Abschnitt finden Sie aktuelle Statistiken zur Qualit\u00e4t der Dokumentation und des Codes.</p>"},{"location":"development/metrics/#api-dokumentationsabdeckung","title":"\ud83d\udcca API-Dokumentationsabdeckung","text":"<p>Wir verwenden <code>interrogate</code>, um sicherzustellen, dass alle \u00f6ffentlichen APIs dokumentiert sind.</p> <p>Aktueller Status: </p> Metrik Wert Abdeckung 100.0% Zielwert &gt; 95% Status \u2705 Bestanden"},{"location":"development/metrics/#testabdeckung","title":"\ud83e\uddea Testabdeckung","text":"<p>Die Testabdeckung gibt an, wie viel Prozent des Quellcodes durch automatisierte Tests gepr\u00fcft werden.</p> Modul Abdeckung <code>redis_client.py</code> 85% <code>redis_image_streamer.py</code> 92% <code>redis_label_manager.py</code> 90% <code>redis_text_overlay.py</code> 93% Gesamt 87%"},{"location":"development/metrics/#code-qualitat","title":"\ud83d\udee0\ufe0f Code-Qualit\u00e4t","text":"Pr\u00fcfung Tool Status Formatierung Black \u2705 Bestanden Linting Ruff \u2705 Bestanden Typpr\u00fcfung mypy \u2705 Bestanden"},{"location":"development/testing/","title":"Tests","text":"<p>Das Projekt verf\u00fcgt \u00fcber eine umfangreiche Testsuite.</p>"},{"location":"development/testing/#tests-ausfuhren","title":"Tests ausf\u00fchren","text":"<p>Installieren Sie die Entwicklungsabh\u00e4ngigkeiten:</p> <pre><code>pip install -r requirements-dev.txt\n</code></pre> <p>F\u00fchren Sie die Tests mit pytest aus:</p> <pre><code>pytest tests/ -v\n</code></pre>"},{"location":"development/testing/#testabdeckung","title":"Testabdeckung","text":"<p>So generieren Sie einen Coverage-Bericht:</p> <pre><code>pytest tests/ --cov=redis_robot_comm --cov-report=term\n</code></pre>"},{"location":"usage/detection/","title":"Objekterkennung Streaming","text":"<p>Der <code>RedisMessageBroker</code> ist die zentrale Komponente f\u00fcr das Streaming von Objekterkennungsdaten.</p>"},{"location":"usage/detection/#objekte-veroffentlichen","title":"Objekte ver\u00f6ffentlichen","text":"<pre><code>from redis_robot_comm import RedisMessageBroker\n\nbroker = RedisMessageBroker()\n\nobjects = [\n    {\n        \"id\": \"obj_001\",\n        \"class_name\": \"cube\",\n        \"confidence\": 0.98,\n        \"position\": {\"x\": 0.5, \"y\": 0.0, \"z\": 0.1}\n    }\n]\n\n# Kamerapose (optional)\ncamera_pose = {\n    \"x\": 0.0, \"y\": 0.0, \"z\": 1.0,\n    \"roll\": 0.0, \"pitch\": 0.0, \"yaw\": 0.0\n}\n\nbroker.publish_objects(objects, camera_pose=camera_pose)\n</code></pre>"},{"location":"usage/detection/#objekte-abrufen","title":"Objekte abrufen","text":""},{"location":"usage/detection/#neueste-objekte-abrufen","title":"Neueste Objekte abrufen","text":"<pre><code># Ruft die neuesten Objekte ab, die nicht \u00e4lter als 2 Sekunden sind\nlatest = broker.get_latest_objects(max_age_seconds=2.0)\n</code></pre>"},{"location":"usage/detection/#objekte-in-einem-zeitbereich-abrufen","title":"Objekte in einem Zeitbereich abrufen","text":"<pre><code>import time\n\nstart = time.time() - 10  # Vor 10 Sekunden\nend = time.time()\nobjects = broker.get_objects_in_timerange(start, end)\n</code></pre>"},{"location":"usage/detection/#abonnement-subscription","title":"Abonnement (Subscription)","text":"<p>Sie k\u00f6nnen auf neue Erkennungen warten, ohne den Stream manuell abzufragen:</p> <pre><code>def on_detection(data):\n    print(f\"Empfangen: {len(data['objects'])} Objekte\")\n\nbroker.subscribe_objects(on_detection)\n</code></pre>"},{"location":"usage/labels/","title":"Label-Verwaltung","text":"<p>Der <code>RedisLabelManager</code> wird verwendet, um die Liste der erkennbaren Objekte dynamisch zu verwalten.</p>"},{"location":"usage/labels/#labels-veroffentlichen","title":"Labels ver\u00f6ffentlichen","text":"<pre><code>from redis_robot_comm import RedisLabelManager\n\nmanager = RedisLabelManager()\nlabels = [\"cube\", \"sphere\", \"cylinder\"]\n\nmanager.publish_labels(labels, metadata={\"model\": \"yolov8-robotics\"})\n</code></pre>"},{"location":"usage/labels/#aktuelle-labels-abrufen","title":"Aktuelle Labels abrufen","text":"<pre><code>current_labels = manager.get_latest_labels()\nif current_labels:\n    print(f\"Erkennbare Objekte: {current_labels}\")\n</code></pre>"},{"location":"usage/labels/#labels-dynamisch-hinzufugen","title":"Labels dynamisch hinzuf\u00fcgen","text":"<pre><code>manager.add_label(\"prism\")\n</code></pre>"},{"location":"usage/streaming/","title":"Bild-Streaming","text":"<p>Der <code>RedisImageStreamer</code> erm\u00f6glicht das effiziente Streaming von OpenCV-Bildern.</p>"},{"location":"usage/streaming/#bilder-senden","title":"Bilder senden","text":"<pre><code>from redis_robot_comm import RedisImageStreamer\nimport cv2\n\nstreamer = RedisImageStreamer(stream_name=\"robot_camera\")\nimage = cv2.imread(\"frame.jpg\")\n\n# Senden mit JPEG-Kompression (Standard)\nstreamer.publish_image(image, quality=85)\n\n# Senden ohne Kompression (verlustfrei)\nstreamer.publish_image(image, compress_jpeg=False)\n</code></pre>"},{"location":"usage/streaming/#bilder-empfangen","title":"Bilder empfangen","text":"<pre><code>result = streamer.get_latest_image()\n\nif result:\n    image, metadata = result\n    cv2.imshow(\"Robot View\", image)\n</code></pre>"},{"location":"usage/streaming/#kontinuierliches-streaming","title":"Kontinuierliches Streaming","text":"<p>Verwenden Sie <code>subscribe_variable_images</code> f\u00fcr eine fl\u00fcssige Anzeige:</p> <pre><code>def on_frame(image, metadata, info):\n    cv2.imshow(\"Live\", image)\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        return False # Beendet die Subscription\n    return True\n\nstreamer.subscribe_variable_images(on_frame)\n</code></pre>"},{"location":"usage/text_overlays/","title":"Text-Overlays","text":"<p>Der <code>RedisTextOverlayManager</code> erm\u00f6glicht das Hinzuf\u00fcgen von Texteinblendungen f\u00fcr Videoaufzeichnungen oder Benutzeroberfl\u00e4chen.</p>"},{"location":"usage/text_overlays/#nachrichten-veroffentlichen","title":"Nachrichten ver\u00f6ffentlichen","text":""},{"location":"usage/text_overlays/#benutzeraufgaben","title":"Benutzeraufgaben","text":"<pre><code>from redis_robot_comm import RedisTextOverlayManager\n\ntext_mgr = RedisTextOverlayManager()\ntext_mgr.publish_user_task(\"Hebe den roten W\u00fcrfel auf.\")\n</code></pre>"},{"location":"usage/text_overlays/#robotersprache","title":"Robotersprache","text":"<pre><code>text_mgr.publish_robot_speech(\"Ich bewege mich jetzt zum W\u00fcrfel.\", duration_seconds=3.0)\n</code></pre>"},{"location":"usage/text_overlays/#systemnachrichten","title":"Systemnachrichten","text":"<pre><code>text_mgr.publish_system_message(\"Aufzeichnung gestartet\", duration_seconds=2.0)\n</code></pre>"},{"location":"usage/text_overlays/#overlays-abonnieren","title":"Overlays abonnieren","text":"<p>Dies wird typischerweise von einem Aufzeichnungsskript verwendet:</p> <pre><code>def display_text(data):\n    print(f\"[{data['type']}] {data['text']}\")\n\ntext_mgr.subscribe_to_texts(display_text)\n</code></pre>"},{"location":"en/","title":"redis_robot_comm","text":"<p>Redis-based communication and streaming package for robotics applications.</p> <p>The <code>redis_robot_comm</code> package provides an efficient Redis-based communication infrastructure for robotics applications. It enables real-time exchange of camera images, object detections, metadata, and text overlays between distributed processes or systems.</p>"},{"location":"en/#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udce6 Object Detection - Streaming of detection results via <code>RedisMessageBroker</code></li> <li>\ud83d\udcf7 Image Streaming - Variable image sizes with JPEG compression via <code>RedisImageStreamer</code></li> <li>\ud83c\udff7\ufe0f Label Management - Dynamic object labels with <code>RedisLabelManager</code></li> <li>\ud83d\udcdd Text Overlays - Video recording integration with <code>RedisTextOverlayManager</code></li> <li>\u26a1 Real-Time Performance - Sub-millisecond latency for local Redis servers</li> <li>\ud83d\udd04 Asynchronous Architecture - Decoupled producer-consumer patterns</li> <li>\ud83d\udcca Rich Metadata Support - Automatic timestamps, camera poses, workspace information</li> <li>\ud83c\udfaf Robotics-Optimized - Specifically designed for pick-and-place and computer vision tasks</li> </ul>"},{"location":"en/#use-cases","title":"Use Cases","text":"<p>This package serves as the communication backbone for robotics frameworks:</p> <ul> <li>vision_detect_segment - Object detection with OwlV2, YOLO-World, YOLOE, Grounding-DINO</li> <li>robot_environment - Robot control with visual object recognition</li> <li>robot_mcp - LLM-based robot control using Model Context Protocol (MCP)</li> </ul>"},{"location":"en/#data-flow","title":"Data Flow","text":""},{"location":"en/configuration/","title":"Configuration","text":"<p><code>redis_robot_comm</code> can be configured via environment variables or directly in the code.</p>"},{"location":"en/configuration/#environment-variables","title":"Environment Variables","text":"<p>The following environment variables are supported:</p> Variable Description Default Value <code>REDIS_HOST</code> Redis server hostname <code>localhost</code> <code>REDIS_PORT</code> Redis server port <code>6379</code> <code>REDIS_DB</code> Redis database index <code>0</code> <code>REDIS_PASSWORD</code> Redis password (optional) <code>None</code>"},{"location":"en/configuration/#configuration-in-code","title":"Configuration in Code","text":"<p>You can pass configuration parameters when initializing the manager classes:</p> <pre><code>from redis_robot_comm import RedisMessageBroker\n\n# Explicit parameters\nbroker = RedisMessageBroker(\n    host=\"192.168.1.100\",\n    port=6380,\n    db=1,\n    stream_name=\"my_objects\"\n)\n</code></pre> <p>Alternatively, you can use a <code>RedisConfig</code> object:</p> <pre><code>from redis_robot_comm.config import RedisConfig\nfrom redis_robot_comm import RedisImageStreamer\n\nconfig = RedisConfig(\n    host=\"localhost\",\n    port=6379,\n    password=\"secret_password\"\n)\n\nstreamer = RedisImageStreamer(config=config)\n</code></pre>"},{"location":"en/configuration/#logging-configuration","title":"Logging Configuration","text":"<p>All classes have a <code>verbose</code> attribute to enable detailed logging output:</p> <pre><code>broker = RedisMessageBroker()\nbroker.verbose = True\n</code></pre>"},{"location":"en/getting-started/","title":"Getting Started","text":"<p>This guide will help you get started with <code>redis_robot_comm</code> quickly.</p>"},{"location":"en/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python \u2265 3.8</li> <li>Redis Server \u2265 5.0 (for Streams support)</li> </ul>"},{"location":"en/getting-started/#quick-start-examples","title":"Quick Start Examples","text":""},{"location":"en/getting-started/#1-object-detection","title":"1. Object Detection","text":"<pre><code>from redis_robot_comm import RedisMessageBroker\nimport time\n\nbroker = RedisMessageBroker()\n\n# Test connection\nif broker.test_connection():\n    print(\"\u2713 Connected to Redis\")\n\n# Publish example objects\nobjects = [\n    {\n        \"id\": \"obj_1\",\n        \"class_name\": \"cube\",\n        \"confidence\": 0.95,\n        \"position\": {\"x\": 0.1, \"y\": 0.2, \"z\": 0.05},\n        \"timestamp\": time.time()\n    }\n]\n\nbroker.publish_objects(objects)\n\n# Retrieve latest objects\nlatest = broker.get_latest_objects(max_age_seconds=2.0)\nprint(f\"Found objects: {len(latest)}\")\n</code></pre>"},{"location":"en/getting-started/#2-image-streaming","title":"2. Image Streaming","text":"<pre><code>from redis_robot_comm import RedisImageStreamer\nimport cv2\n\nstreamer = RedisImageStreamer()\n\n# Load example image\nimage = cv2.imread(\"example.jpg\")\n\n# Publish image\nstreamer.publish_image(image, compress_jpeg=True, quality=85)\n\n# Retrieve latest image\nresult = streamer.get_latest_image()\nif result:\n    img, metadata = result\n    cv2.imshow(\"Received Image\", img)\n    cv2.waitKey(0)\n</code></pre>"},{"location":"en/getting-started/#more-information","title":"More Information","text":"<p>For detailed information about individual modules, please visit the Usage and API Reference sections.</p>"},{"location":"en/installation/","title":"Installation","text":"<p>This section describes how to install and set up <code>redis_robot_comm</code>.</p>"},{"location":"en/installation/#install-package","title":"Install Package","text":"<p>You can install the package directly from the source code:</p> <pre><code>git clone https://github.com/dgaida/redis_robot_comm.git\ncd redis_robot_comm\npip install -e .\n</code></pre>"},{"location":"en/installation/#set-up-redis-server","title":"Set up Redis Server","text":"<p><code>redis_robot_comm</code> requires a running Redis server (version \u2265 5.0).</p>"},{"location":"en/installation/#using-docker-recommended","title":"Using Docker (Recommended)","text":"<p>This is the easiest way to start Redis quickly:</p> <pre><code>docker run -d -p 6379:6379 --name redis-robot redis:alpine\n</code></pre>"},{"location":"en/installation/#local-installation","title":"Local Installation","text":"<p>Ubuntu/Debian: <pre><code>sudo apt-get update\nsudo apt-get install redis-server\nsudo systemctl start redis-server\n</code></pre></p> <p>macOS: <pre><code>brew install redis\nbrew services start redis\n</code></pre></p>"},{"location":"en/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, you can test the connection with a simple script:</p> <pre><code>from redis_robot_comm import RedisMessageBroker\n\ntry:\n    broker = RedisMessageBroker()\n    if broker.test_connection():\n        print(\"\u2713 Installation successful: Connection to Redis established.\")\n    else:\n        print(\"\u2717 Connection to Redis failed.\")\nexcept Exception as e:\n    print(f\"\u2717 Verification error: {e}\")\n</code></pre>"},{"location":"en/troubleshooting/","title":"Troubleshooting","text":"<p>Here you will find solutions to common problems.</p>"},{"location":"en/troubleshooting/#redis-connection-issues","title":"Redis Connection Issues","text":""},{"location":"en/troubleshooting/#error-message-failed-to-connect-to-redis","title":"Error Message: <code>Failed to connect to Redis</code>","text":"<p>Possible Causes: 1. Redis server is not running. 2. Incorrect host or port configuration. 3. Firewall is blocking access.</p> <p>Solutions: * Check if Redis is running: <code>redis-cli ping</code> should respond with <code>PONG</code>. * Ensure the Docker container is running (if used): <code>docker ps</code>. * Check your <code>REDIS_HOST</code> and <code>REDIS_PORT</code> settings.</p>"},{"location":"en/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"en/troubleshooting/#high-latency-during-image-streaming","title":"High Latency during Image Streaming","text":"<p>Possible Causes: 1. Large images without compression. 2. Network bandwidth is saturated. 3. High CPU load due to JPEG encoding.</p> <p>Solutions: * Enable JPEG compression: <code>compress_jpeg=True</code>. * Reduce JPEG quality: <code>quality=70</code>. * Decrease image resolution before sending.</p>"},{"location":"en/troubleshooting/#data-loss","title":"Data Loss","text":""},{"location":"en/troubleshooting/#old-messages-disappear-from-the-stream","title":"Old Messages Disappear from the Stream","text":"<p>Cause: * The <code>maxlen</code> parameters (default 500 for objects, 5 for images) limit the number of stored entries.</p> <p>Solution: * Increase the <code>maxlen</code> value when publishing if you need a larger buffer.</p>"},{"location":"en/troubleshooting/#debugging","title":"Debugging","text":"<p>Enable <code>verbose</code> mode to get more information about internal operations:</p> <pre><code>streamer = RedisImageStreamer()\nstreamer.verbose = True\n</code></pre>"},{"location":"en/architecture/","title":"Architecture Overview","text":""},{"location":"en/architecture/#system-design","title":"System Design","text":"<p>The system is based on a decentralized architecture where Redis acts as the central message broker for all data streams.</p>"},{"location":"en/architecture/#component-diagram","title":"Component Diagram","text":"graph TD     subgraph Client Applications         VD[Vision Detection]         RC[Robot Control]         MCP[MCP Server]     end      subgraph redis_robot_comm         RMB[RedisMessageBroker]         RIS[RedisImageStreamer]         RLM[RedisLabelManager]         RTO[RedisTextOverlayManager]     end      subgraph Redis Infrastructure         RS[(Redis Streams)]     end      VD --&gt; RMB     VD --&gt; RIS     RC --&gt; RMB     RC --&gt; RIS     MCP --&gt; RTO      RMB &lt;--&gt; RS     RIS &lt;--&gt; RS     RLM &lt;--&gt; RS     RTO &lt;--&gt; RS"},{"location":"en/architecture/#core-components","title":"Core Components","text":""},{"location":"en/architecture/#redismessagebroker","title":"RedisMessageBroker","text":"<p>Responsible for streaming object detection data in JSON format. Supports camera poses and timestamps.</p>"},{"location":"en/architecture/#redisimagestreamer","title":"RedisImageStreamer","text":"<p>Enables streaming of OpenCV images with optional JPEG compression. Optimized for low latency.</p>"},{"location":"en/architecture/#redislabelmanager","title":"RedisLabelManager","text":"<p>Dynamically manages the list of detectable objects between different processes.</p>"},{"location":"en/architecture/#redistextoverlaymanager","title":"RedisTextOverlayManager","text":"<p>Synchronizes text overlays for video recordings, categorized into user tasks, robot speech, and system messages.</p>"},{"location":"en/architecture/data_flow/","title":"Data Flow","text":"<p>Data exchange occurs asynchronously via Redis Streams. This allows for decoupling of producers (e.g., camera drivers, AI models) and consumers (e.g., robot control, visualization).</p>"},{"location":"en/architecture/data_flow/#image-streaming-sequence","title":"Image Streaming Sequence","text":"sequenceDiagram     participant P as Publisher (e.g., Camera)     participant R as Redis Stream     participant C as Consumer (e.g., GUI)      P-&gt;&gt;P: Capture Image     P-&gt;&gt;P: Compress to JPEG     P-&gt;&gt;R: XADD robot_camera (image_data, metadata)     R--&gt;&gt;P: Stream ID      C-&gt;&gt;R: XREAD/XREVRANGE robot_camera     R--&gt;&gt;C: Image Data + Metadata     C-&gt;&gt;C: Decode JPEG     C-&gt;&gt;C: Display Image"},{"location":"en/architecture/data_flow/#object-detection-workflow","title":"Object Detection Workflow","text":"flowchart LR     Img[Image Source] --&gt; Det[Detector]     Det --&gt; |Object List| Broker[RedisMessageBroker]     Broker --&gt; |XADD| Stream[(Redis Stream)]     Stream --&gt; |XREAD| Control[Robot Control]     Control --&gt; |Action| Robot[Robot]"},{"location":"en/development/contributing/","title":"Contributing","text":"<p>We welcome contributions to the project!</p>"},{"location":"en/development/contributing/#development-process","title":"Development Process","text":"<ol> <li>Fork the repository.</li> <li>Create a new branch for your changes.</li> <li>Implement your changes and add tests.</li> <li>Ensure all tests pass.</li> <li>Create a pull request.</li> </ol>"},{"location":"en/development/contributing/#code-style","title":"Code Style","text":"<p>We use: - Black for formatting. - Ruff for linting. - mypy for type checking.</p> <p>Run <code>pre-commit install</code> to automatically perform these checks before each commit.</p>"},{"location":"en/development/metrics/","title":"Documentation Quality Metrics","text":"<p>In this section, you will find current statistics on the quality of the documentation and the code.</p>"},{"location":"en/development/metrics/#api-documentation-coverage","title":"\ud83d\udcca API Documentation Coverage","text":"<p>We use <code>interrogate</code> to ensure that all public APIs are documented.</p> <p>Current Status: </p> Metric Value Coverage 100.0% Threshold &gt; 95% Status \u2705 Passed"},{"location":"en/development/metrics/#test-coverage","title":"\ud83e\uddea Test Coverage","text":"<p>Test coverage indicates the percentage of source code verified by automated tests.</p> Module Coverage <code>redis_client.py</code> 85% <code>redis_image_streamer.py</code> 92% <code>redis_label_manager.py</code> 90% <code>redis_text_overlay.py</code> 93% Total 87%"},{"location":"en/development/metrics/#code-quality","title":"\ud83d\udee0\ufe0f Code Quality","text":"Check Tool Status Formatting Black \u2705 Passed Linting Ruff \u2705 Passed Type Checking mypy \u2705 Passed"},{"location":"en/development/testing/","title":"Testing","text":"<p>The project has an extensive test suite.</p>"},{"location":"en/development/testing/#running-tests","title":"Running Tests","text":"<p>Install development dependencies:</p> <pre><code>pip install -r requirements-dev.txt\n</code></pre> <p>Run tests with pytest:</p> <pre><code>pytest tests/ -v\n</code></pre>"},{"location":"en/development/testing/#test-coverage","title":"Test Coverage","text":"<p>To generate a coverage report:</p> <pre><code>pytest tests/ --cov=redis_robot_comm --cov-report=term\n</code></pre>"},{"location":"en/usage/detection/","title":"Object Detection Streaming","text":"<p>The <code>RedisMessageBroker</code> is the central component for streaming object detection data.</p>"},{"location":"en/usage/detection/#publishing-objects","title":"Publishing Objects","text":"<pre><code>from redis_robot_comm import RedisMessageBroker\n\nbroker = RedisMessageBroker()\n\nobjects = [\n    {\n        \"id\": \"obj_001\",\n        \"class_name\": \"cube\",\n        \"confidence\": 0.98,\n        \"position\": {\"x\": 0.5, \"y\": 0.0, \"z\": 0.1}\n    }\n]\n\n# Camera pose (optional)\ncamera_pose = {\n    \"x\": 0.0, \"y\": 0.0, \"z\": 1.0,\n    \"roll\": 0.0, \"pitch\": 0.0, \"yaw\": 0.0\n}\n\nbroker.publish_objects(objects, camera_pose=camera_pose)\n</code></pre>"},{"location":"en/usage/detection/#retrieving-objects","title":"Retrieving Objects","text":""},{"location":"en/usage/detection/#getting-latest-objects","title":"Getting Latest Objects","text":"<pre><code># Retrieves the latest objects, no older than 2 seconds\nlatest = broker.get_latest_objects(max_age_seconds=2.0)\n</code></pre>"},{"location":"en/usage/detection/#querying-objects-in-time-range","title":"Querying Objects in Time Range","text":"<pre><code>import time\n\nstart = time.time() - 10  # 10 seconds ago\nend = time.time()\nobjects = broker.get_objects_in_timerange(start, end)\n</code></pre>"},{"location":"en/usage/detection/#subscription","title":"Subscription","text":"<p>You can wait for new detections without manually polling the stream:</p> <pre><code>def on_detection(data):\n    print(f\"Received: {len(data['objects'])} objects\")\n\nbroker.subscribe_objects(on_detection)\n</code></pre>"},{"location":"en/usage/labels/","title":"Label Management","text":"<p>The <code>RedisLabelManager</code> is used to dynamically manage the list of detectable objects.</p>"},{"location":"en/usage/labels/#publishing-labels","title":"Publishing Labels","text":"<pre><code>from redis_robot_comm import RedisLabelManager\n\nmanager = RedisLabelManager()\nlabels = [\"cube\", \"sphere\", \"cylinder\"]\n\nmanager.publish_labels(labels, metadata={\"model\": \"yolov8-robotics\"})\n</code></pre>"},{"location":"en/usage/labels/#retrieving-latest-labels","title":"Retrieving Latest Labels","text":"<pre><code>current_labels = manager.get_latest_labels()\nif current_labels:\n    print(f\"Detectable objects: {current_labels}\")\n</code></pre>"},{"location":"en/usage/labels/#adding-labels-dynamically","title":"Adding Labels Dynamically","text":"<pre><code>manager.add_label(\"prism\")\n</code></pre>"},{"location":"en/usage/streaming/","title":"Image Streaming","text":"<p>The <code>RedisImageStreamer</code> enables efficient streaming of OpenCV images.</p>"},{"location":"en/usage/streaming/#sending-images","title":"Sending Images","text":"<pre><code>from redis_robot_comm import RedisImageStreamer\nimport cv2\n\nstreamer = RedisImageStreamer(stream_name=\"robot_camera\")\nimage = cv2.imread(\"frame.jpg\")\n\n# Send with JPEG compression (default)\nstreamer.publish_image(image, quality=85)\n\n# Send without compression (lossless)\nstreamer.publish_image(image, compress_jpeg=False)\n</code></pre>"},{"location":"en/usage/streaming/#receiving-images","title":"Receiving Images","text":"<pre><code>result = streamer.get_latest_image()\n\nif result:\n    image, metadata = result\n    cv2.imshow(\"Robot View\", image)\n</code></pre>"},{"location":"en/usage/streaming/#continuous-streaming","title":"Continuous Streaming","text":"<p>Use <code>subscribe_variable_images</code> for a smooth display:</p> <pre><code>def on_frame(image, metadata, info):\n    cv2.imshow(\"Live\", image)\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        return False # Stops the subscription\n    return True\n\nstreamer.subscribe_variable_images(on_frame)\n</code></pre>"},{"location":"en/usage/text_overlays/","title":"Text Overlays","text":"<p>The <code>RedisTextOverlayManager</code> allows adding text overlays for video recordings or user interfaces.</p>"},{"location":"en/usage/text_overlays/#publishing-messages","title":"Publishing Messages","text":""},{"location":"en/usage/text_overlays/#user-tasks","title":"User Tasks","text":"<pre><code>from redis_robot_comm import RedisTextOverlayManager\n\ntext_mgr = RedisTextOverlayManager()\ntext_mgr.publish_user_task(\"Pick up the red cube.\")\n</code></pre>"},{"location":"en/usage/text_overlays/#robot-speech","title":"Robot Speech","text":"<pre><code>text_mgr.publish_robot_speech(\"I am moving to the cube now.\", duration_seconds=3.0)\n</code></pre>"},{"location":"en/usage/text_overlays/#system-messages","title":"System Messages","text":"<pre><code>text_mgr.publish_system_message(\"Recording started\", duration_seconds=2.0)\n</code></pre>"},{"location":"en/usage/text_overlays/#subscribing-to-overlays","title":"Subscribing to Overlays","text":"<p>This is typically used by a recording script:</p> <pre><code>def display_text(data):\n    print(f\"[{data['type']}] {data['text']}\")\n\ntext_mgr.subscribe_to_texts(display_text)\n</code></pre>"}]}